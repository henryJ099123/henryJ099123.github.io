[
    {
        "name": "rainbow.frag",
        "data": "//fragment shader which draws a moving rainbow to the screen\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nvec3 colorA = vec3(0.149,0.141,0.912);\nvec3 colorB = vec3(1.000,0.833,0.224);\nvec3 white = vec3(1.0);\n\nfloat plot (vec2 st, float pct){\n  return  smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.01, st.y);\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec3 color = vec3(0.0);\n\n    vec3 pct;\n    \n    float adv = st.x + u_time;\n\n    pct.r = clamp(0.5 + cos(2.0*PI*adv), 0.0, 1.0);\n    pct.g = clamp(0.5 + sin(2.0*PI*(adv-1.0/12.0)), 0.0, 1.0);\n    pct.b = clamp(0.5 + sin(2.0*PI*(adv - 5.0/12.0)), 0.0, 1.0);\n\n    // pct.r = smoothstep(0.0,1.0, st.x);\n    // pct.g = sin(st.x*PI);\n    // pct.b = pow(st.x,0.5);\n\tcolor = pct;\n    //color = mix(colorA, colorB, pct);\n\n    // Plot transition lines for each channel\n//    color = mix(color,vec3(1.0,0.0,0.0),plot(st,pct.r));\n  //  color = mix(color,vec3(0.0,1.0,0.0),plot(st,pct.g));\n    //color = mix(color,vec3(0.0,0.0,1.0),plot(st,pct.b));\n\n    gl_FragColor = vec4(color,1.0);\n}\n\n"
    },
    {
        "name": "ui.frag",
        "data": "//ui.frag\n//playing with circles, rings, and arcs, and rotation\n//has many reusable functions\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nmat2 rotate(float theta) {\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nfloat get_angle_normed(in vec2 uv) {\n    return atan(uv.y, uv.x) / 2.0 / PI + 0.5;\n}\n\nfloat circle(in vec2 _st, in float _radius) {\n    return 1.0 - step(_radius, length(_st));\n}\n\n// float circle_polar(in vec2 _rtheta, in float _radius) {\n//     return 1.0 - step(_radius, length(vec2()))\n// }\n\nfloat ring(in vec2 _st, in float _inner_rad, in float _width) {\n    return step(_inner_rad, length(_st)) * step(length(_st), _inner_rad + _width);\n}\n\n//_pct_arc is %age of circumference the arc contains\n//aka angle of the arc but in normed angle\nfloat arc(in vec2 _center, in float _rad, in float _thickness, in float _pct_arc, in float _rotation) {\n    _center *= rotate(_rotation);\n    float angle = get_angle_normed(_center);\n    \n    //radius outward\n    float is_on_arc = step(_rad, length(_center)) * step(length(_center), _rad + _thickness);\n    \n    //what's on the arc\n    is_on_arc *= step(angle, _pct_arc);\n    \n    return is_on_arc;\n}\n\n// float box(in vec2 _st, in vec2 _size){\n//     _size = vec2(0.5) - _size*0.5;\n//     vec2 uv = smoothstep(_size,\n//                         _size+vec2(0.001),\n//                         _st);\n//     uv *= smoothstep(_size,\n//                     _size+vec2(0.001),\n//                     vec2(1.0)-_st);\n//     return uv.x*uv.y;\n// }\n\n// float cross(in vec2 _st, float _size){\n//     return  box(_st, vec2(_size,_size/4.)) +\n//             box(_st, vec2(_size/4.,_size));\n// }\n\nvoid main(){\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x / u_resolution.y;\n\n    st -= vec2(0.5);\n    \n    //st *= rotate(0.5);\n    vec2 polar = vec2(0.0);\n    polar.r = length(st);\n    polar.g = get_angle_normed(st);\n    \n    vec3 color = vec3(0.0);\n\t\n\n//     st -= vec2(0.5);\n//     st = scale( vec2(sin(u_time)+1.0) ) * st;\n//     st += vec2(0.5);\n\n//     // Show the coordinates of the space on the background\n//     // color = vec3(st.x,st.y,0.0);\n\n//     // Add the shape on the foreground\n//     color += vec3(cross(st,0.2));\n    \n    //arcs in the center\n    color += vec3(arc(st, 0.08, 0.02, 0.2, 0.2));\n    color += vec3(arc(st, 0.08, 0.02, 0.2, PI+0.2));\n    color += vec3(arc(st, 0.08, 0.02, 0.2, PI/2.0+0.2));\n    color += vec3(arc(st, 0.08, 0.02, 0.2, -PI/2.0+0.2));\n    \n    //rings\n\tcolor += vec3(ring(st, 0.4, 0.025));\n    color += vec3(ring(st, 0.28, 0.025));\n    \n    //center circle\n    color += circle(st, 0.01);\n    \n    //outside circles\n    for(int i = 0; i < 4; i++) {\n    \tcolor += circle(vec2(st.x+0.45*cos(float(i)*PI/2.), st.y + 0.45*sin(float(i)*PI/2.)), 0.010);\n    }\n    \n    //lines within rings\n\tfloat pct = step(0.32, polar.r) * step(polar.r, 0.38);\n    pct *= step(0.02, mod(polar.g, 0.05)) - step(0.03, mod(polar.g, 0.05));\n    color += vec3(pct);\n    \n    gl_FragColor = vec4(color,1.0);\n}\n\n"
    },
    {
        "name": "cellular_noise.frag",
        "data": "//cellular_noise.frag\n//playing with cellular noise and some\n//REALLY annoying \n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define PI 3.141592653589793\n\nvec2 random2( vec2 p) {\n    p.y = mod(p.y, 10.);\n    return fract(sin(\n        vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)))\n                    )*43758.5453);\n}\n\nvec3 hardlines_voronoi(vec2 st) {\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    float mdist = 8.0;\n    vec2 mdiff;\n    \n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 rPoint = random2(n + ipos);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            if(dist < mdist) {\n                mdist = dist;\n                mdiff = diff;\n            } \n\t\t}\n    }\n    \n    mdist = 8.0;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 rPoint = random2(n + ipos);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            \n            if(dot(mdiff-diff, mdiff-diff) > 0.0001) {\n                mdist = min(mdist, abs(dot(0.5*(mdiff+diff), normalize(mdiff-diff))));\n            }\n\t\t}\n    }\n    return vec3(mdist, mdiff);\n}\n\nvec3 hardlines_voronoi_with_point(in vec2 st, in float scale, in vec2 point) {\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    float mdist = 8.0;\n    vec2 mdiff;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n        \tvec2 n = vec2(float(i), float(j));\n            vec2 inp = n+ipos;\n            inp.y = mod(inp.y, scale);\n            vec2 rPoint = random2(inp);\n            //rPoint = 0.5+0.5 * sin(u_time+2.*PI*rPoint);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            if(dist < mdist) {\n                mdist = dist;\n                mdiff = diff;\n            } \n\t\t}\n    }\n\n    for(int i = -1; i <= 1; i++) {\n        vec2 pointDiff = point + vec2(0., scale*float(i)) - ipos - fpos;\n        if(dot(pointDiff, pointDiff) < mdist) {\n            mdist = dot(pointDiff, pointDiff);\n            mdiff = pointDiff;\n        }\n    }\n    \n    mdist = 8.0;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 inp = n+ipos;\n            inp.y = mod(inp.y, scale);\n            vec2 rPoint = random2(inp);\n            //rPoint = 0.5+0.5 * sin(u_time+2.*PI*rPoint);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            \n            if(dot(mdiff-diff, mdiff-diff) > 0.0001) {\n                mdist = min(mdist, abs(dot(0.5*(mdiff+diff), normalize(mdiff-diff))));\n            }\n\t\t}\n    }\n    return vec3(mdist, mdiff);\n}\n\nvec2 transform(in vec2 st, float scale, vec2 pre_translate, vec2 post_translate) {\n    st -= pre_translate;\n    vec2 uv = vec2(length(st), atan(st.y, st.x));\n    //if(st.x < 0.) uv.y += PI;\n    //uv.y = 0.;\n    uv.y = uv.y/2./PI + 0.5;\n    //uv.y = .5-.5*cos(2.*uv.y*PI);\n    //uv.y = 1.-pow((2.*(uv.y-0.5)),2.);\n    uv *= scale;\n    //uv.y = mod(uv.y, scale);\n    uv.r = 5. * sin(uv.r);\n    uv += post_translate;\n    return uv;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n    const float SCALE = 10.;\n    vec2 mouse = u_mouse / u_resolution;\n    mouse.x *= u_resolution.x / u_resolution.y;\n    vec3 color = vec3(0.0);\n    \n//     st -= 0.5;\n    \n//     st = vec2(length(st), atan(st.y, st.x));\n//     st.y = st.y/2./PI + 0.5;\n//     st *= SCALE;\n    st = transform(st, SCALE, vec2(0.5), vec2(u_time*0.75, u_time*0.25));\n\tmouse = transform(mouse, SCALE, vec2(0.5), vec2(u_time*0.75, u_time*0.25));\n    \n\tvec3 voronoi = hardlines_voronoi_with_point(st, SCALE, mouse);\n\n    color += vec3(step(voronoi.x, 0.02));\n    //color *= mix(color, vec3(0.2902, 0.4824, 0.9608), voronoi.x);\n\n//     // Show isolines\n//     color -= abs(sin(80.0*m_dist))*0.07;\n\n\t//color += step(length(voronoi.yz), 0.02);\n    \n   //color.r += step(0.98, fract(st.x)) + step(0.98, fract(st.y));// + step(st.y, 4.936);\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "fbm_practice.frag",
        "data": "// fbm_practice.frag\n// working on some fractal brownian motion\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(1.234,56.789)))*\n        123456.789);\n}\n\n//noise function by interpolating between corners of square\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of square\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define ITERATIONS 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float val = 0.;\n    float amplitude = .5;\n    float frequency = 1.5; \n    float amp_scale = .5; //should be less than 1\n    float freq_scale = 2.; //should be greater than 1\n    \n    //number of \"octaves\" / scaled waves\n    for (int i = 0; i < ITERATIONS; i++) {\n        val += amplitude * noise(st * frequency);\n        frequency *= freq_scale;\n        amplitude *= amp_scale;\n    }\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n\tst *= 4.5;\n\t\n    vec3 color = vec3(0.0);\n    //float fbm0 = fbm(st+vec2(0.490,0.020)+fbm(st+vec2(-0.240,0.090)+fbm(st+10.*vec2(0.680,0.310))));\n    float fbm1 = fbm(st+10.*vec2(0.680,0.310) - vec2(0.3, 0.1)*u_time);\n    float fbm2 = fbm(st+vec2(-0.240,0.090)+fbm1 + vec2(0.3*sin(st.x+u_time+noise(st)), 0.5 * u_time));\n    float fbm3 = fbm(st+vec2(0.490,0.020) + fbm2+0.3*u_time);\n     \n    //change this value to see different color saturations\n    //right now, 0, 1 or not those :D\n    //I don't *fully* understand these--mostly just playing with values--but I'm getting there\n    int color_choice = 3;\n    if(color_choice == 0) {\n        //color option 1\n        color += mix(vec3(0.), vec3(0.980,0.318,0.004), fbm1);\n        color += mix(vec3(0.), vec3(0.3216, 0.3882, 0.349), fbm2);\n        color += mix(vec3(0.276,0.756,1.000), vec3(0.002,0.000,0.170), fbm3);\n    }\n    else if(color_choice == 1) {\n        //color option 2\n        color = mix(vec3(0.276,0.756,1.000), vec3(0.980,0.318,0.004), fbm1);\n        color += mix(color, vec3(0.3216, 0.3882, 0.349), fbm2);\n        color *= mix(color, vec3(0.002,0.000,0.170), fbm3);\n    }\n    else if(color_choice == 2) {\n        color = mix(vec3(1.0, 0.2902, 0.4667), vec3(0.9804, 0.4745, 0.0039), fbm1);\n        color = mix(color, vec3(0.6157, 0.9765, 0.7412), fbm2);\n        color = mix(color, vec3(0.149, 0.0824, 0.4118), fbm3);\n    }\n    else {\n        color -= mix(vec3(1.0, 0.2902, 0.4667), vec3(0.9804, 0.4745, 0.0039), fbm1);\n        color += mix(color, vec3(1.0, 1.0, 1.0), fbm2);\n        color *= mix(color, vec3(0.2353, 0.0706, 0.4353), fbm3);\n    }\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    }
]