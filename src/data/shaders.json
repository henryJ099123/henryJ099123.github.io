[
    {
        "name": "cells_wall.frag",
        "data": "//cellular_noise.frag\n//playing with cellular noise and some\n//REALLY annoying \n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define PI 3.141592653589793\n\nvec2 random2( vec2 p) {\n    p.y = mod(p.y, 10.);\n    return fract(sin(\n        vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)))\n                    )*43758.5453);\n}\n\nvec3 hardlines_voronoi(vec2 st) {\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    float mdist = 8.0;\n    vec2 mdiff;\n    \n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 rPoint = random2(n + ipos);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            if(dist < mdist) {\n                mdist = dist;\n                mdiff = diff;\n            } \n\t\t}\n    }\n    \n    mdist = 8.0;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 rPoint = random2(n + ipos);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            \n            if(dot(mdiff-diff, mdiff-diff) > 0.0001) {\n                mdist = min(mdist, abs(dot(0.5*(mdiff+diff), normalize(mdiff-diff))));\n            }\n\t\t}\n    }\n    return vec3(mdist, mdiff);\n}\n\nvec3 hardlines_voronoi_with_point(in vec2 st, in float scale, in vec2 point) {\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    float mdist = 8.0;\n    vec2 mdiff;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n        \tvec2 n = vec2(float(i), float(j));\n            vec2 inp = n+ipos;\n            inp.y = mod(inp.y, scale);\n            vec2 rPoint = random2(inp);\n            //rPoint = 0.5+0.5 * sin(u_time+2.*PI*rPoint);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            if(dist < mdist) {\n                mdist = dist;\n                mdiff = diff;\n            } \n\t\t}\n    }\n\n    for(int i = -1; i <= 1; i++) {\n        vec2 pointDiff = point + vec2(0., scale*float(i)) - ipos - fpos;\n        if(dot(pointDiff, pointDiff) < mdist) {\n            mdist = dot(pointDiff, pointDiff);\n            mdiff = pointDiff;\n        }\n    }\n    \n    mdist = 8.0;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 inp = n+ipos;\n            inp.y = mod(inp.y, scale);\n            vec2 rPoint = random2(inp);\n            //rPoint = 0.5+0.5 * sin(u_time+2.*PI*rPoint);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            \n            if(dot(mdiff-diff, mdiff-diff) > 0.0001) {\n                mdist = min(mdist, abs(dot(0.5*(mdiff+diff), normalize(mdiff-diff))));\n            }\n\t\t}\n    }\n    return vec3(mdist, mdiff);\n}\n\nvec2 transform(in vec2 st, float scale, vec2 pre_translate, vec2 post_translate) {\n    st -= pre_translate;\n    vec2 uv = st;\n    // vec2 uv = vec2(length(st), atan(st.y, st.x));\n    //if(st.x < 0.) uv.y += PI;\n    //uv.y = 0.;\n    // uv.y = uv.y/2./PI + 0.5;\n    //uv.y = .5-.5*cos(2.*uv.y*PI);\n    //uv.y = 1.-pow((2.*(uv.y-0.5)),2.);\n    uv *= scale;\n    // uv.y = mod(uv.y, scale);\n    uv.x = 2. * cos(uv.x);\n    // uv.y = length(uv);\n    // uv.y = 1. * sin(uv.y);\n    uv += post_translate;\n    return uv;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n    const float SCALE = 10.;\n    vec2 mouse = u_mouse / u_resolution;\n    mouse.x *= u_resolution.x / u_resolution.y;\n    // vec3 color = vec3(0.2745, 0.0118, 0.0118);\n    vec3 color = vec3(0.);\n    \n//     st -= 0.5;\n    \n//     st = vec2(length(st), atan(st.y, st.x));\n//     st.y = st.y/2./PI + 0.5;\n//     st *= SCALE;\n    st = transform(st, SCALE, vec2(0.5), vec2(u_time, u_time) * vec2(.4, 0.15));\n\tmouse = transform(mouse, SCALE, vec2(0.5), vec2(u_time, u_time) * vec2(0.4, 0.15));\n    \n\tvec3 voronoi = hardlines_voronoi_with_point(st, SCALE, mouse);\n\n    color += vec3(step(voronoi.x, 0.02));\n    // color += vec3(smoothstep(0.02, 0., voronoi.x));\n    //\n    // color = mix(color, vec3(1.0, 0.2353, 0.0), voronoi.z);\n\n//     // Show isolines\n    //color -= abs(sin(80.0*m_dist))*0.07;\n\n\t//color += step(length(voronoi.yz), 0.02);\n    \n   //color.r += step(0.98, fract(st.x)) + step(0.98, fract(st.y));// + step(st.y, 4.936);\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "fbm_orange.frag",
        "data": "// fbm_practice.frag\n// working on some fractal brownian motion\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(1.234,56.789)))*\n        123456.789);\n}\n\nvec2 sin2(in float x, in float y) {\n    return vec2(sin(x), sin(y));\n}\n\n//noise function by interpolating between corners of square\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of square\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define ITERATIONS 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float val = 0.;\n    float amplitude = .5;\n    float frequency = 1.5; \n    float amp_scale = .5; //should be less than 1\n    float freq_scale = 2.; //should be greater than 1\n    \n    //number of \"octaves\" / scaled waves\n    for (int i = 0; i < ITERATIONS; i++) {\n        val += amplitude * noise(st * frequency);\n        frequency *= freq_scale;\n        amplitude *= amp_scale;\n    }\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec2 mouse = u_mouse / u_resolution;\n    mouse.x *= u_resolution.x/u_resolution.y;\n    st.x *= u_resolution.x/u_resolution.y;\n    vec2 rt = st - vec2(0.5);\n\tst *= 4.5;\n    mouse *= 4.5;\n    rt = vec2(length(rt) * 10., atan(rt.y, rt.x));\n    float time = u_time;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    //float fbm0 = fbm(st+vec2(0.490,0.020)+fbm(st+vec2(-0.240,0.090)+fbm(st+10.*vec2(0.680,0.310))));\n    float fbm1 = fbm(st*0.65+time/10.);\n    float fbm2 = fbm(st*fbm1 + time/5. - cos(time/10.));\n    float fbm3 = fbm(st + fbm2 + vec2(-time/15., time / 15.));\n    float fbm4 = fbm(0.5*sin(st*2.) + fbm3 + time/2.);\n\n\n    //different color variations happening over here!\n    color = vec3(1.);\n    color = mix(vec3(0.4314, 0.0, 0.0), vec3(0.0, 1.0, 0.8353), fbm1);\n    color = mix(color, vec3(1.0, 0.2824, 0.0), fbm2);\n    color = mix(color, vec3(0.0, 0.0, 0.0), fbm3);\n    // color = mix(color, vec3(0.4941, 0.0, 0.0), .5*fbm4);\n    color *= 1.8;\n\n    //comment out the following line to remove the mouse functionality\n    // if (!(u_mouse.x <= 25. || u_mouse.x >= u_resolution.x -25. || u_mouse.y <= 25. || u_mouse.y >= u_resolution.y - 25.)) {\n    //     color = mix(color, color / 2., 1.-smoothstep(0.7, 1., 0.8*length(st-mouse)+fbm3));\n    //     //color *= mix(vec3(0.0, 0.0, 0.0), vec3(1.) , smoothstep(0.9, 1., 0.8*length(st-mouse)+fbm3));\n    // }\n\n    // color = mix(color, vec3(0.0, 0.0, 0.0),1. - step(0.1, (length(st-mouse))));\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "fbm_clouds.frag",
        "data": "// fbm_practice.frag\n// working on some fractal brownian motion\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(1.234,56.789)))*\n        123456.789);\n}\n\n//noise function by interpolating between corners of square\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of square\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define ITERATIONS 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float val = 0.;\n    float amplitude = .5;\n    float frequency = 1.5; \n    float amp_scale = .5; //should be less than 1\n    float freq_scale = 2.; //should be greater than 1\n    \n    //number of \"octaves\" / scaled waves\n    for (int i = 0; i < ITERATIONS; i++) {\n        val += amplitude * noise(st * frequency);\n        frequency *= freq_scale;\n        amplitude *= amp_scale;\n    }\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n\tst *= 4.5;\n\n    float time = u_time;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    //float fbm0 = fbm(st+vec2(0.490,0.020)+fbm(st+vec2(-0.240,0.090)+fbm(st+10.*vec2(0.680,0.310))));\n    float fbm1 = fbm(st+5.*vec2(-0.5,1.5)*.05*cos(0.125*time) - 2.*vec2(0.25, 0.1)*time);\n    float fbm2 = fbm(st+vec2(-0.240,0.090)+0.5*fbm1+ vec2(-0.5 * time, 0.3*sin(st.y+time+noise(st))));\n    float fbm3 = fbm(st+vec2(0.490,0.020)*fbm2 + vec2(0.5, 0.5)*0.1*sin(1.5*time) + 0.1*time + fbm1);\n     \n    //different color variations happening over here!\n    int picker = 1;\n    if(picker == 0) {\n        color += mix(vec3(0.0863, 0.8627, 0.7451), vec3(0.0706, 0.2784, 0.098), fbm1);\n        color += mix(vec3(0.9176, 0.4431, 0.4431), vec3(0.6039, 0.0471, 0.5294), fbm2);\n        color *= mix(color, vec3(0.0392, 0.149, 0.4471), fbm3);\n    }\n    else {\n        color += mix(vec3(0.0863, 0.8627, 0.7451), vec3(0.0745, 0.2118, 0.2039), fbm1);\n        color += mix(color, vec3(0.6039, 0.0471, 0.5294), fbm2);\n        color *= mix(color, vec3(0.0392, 0.149, 0.4471), fbm3);\n    }\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "fbm_op.frag",
        "data": "// fbm_practice.frag\n// working on some fractal brownian motion\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(1.234,56.789)))*\n        123456.789);\n}\n\nvec2 sin2(in float x, in float y) {\n    return vec2(sin(x), sin(y));\n}\n\n//noise function by interpolating between corners of square\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of square\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define ITERATIONS 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float val = 0.;\n    float amplitude = .5;\n    float frequency = 1.5; \n    float amp_scale = .5; //should be less than 1\n    float freq_scale = 2.; //should be greater than 1\n    \n    //number of \"octaves\" / scaled waves\n    for (int i = 0; i < ITERATIONS; i++) {\n        val += amplitude * noise(st * frequency);\n        frequency *= freq_scale;\n        amplitude *= amp_scale;\n    }\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec2 mouse = u_mouse / u_resolution;\n    mouse.x *= u_resolution.x/u_resolution.y;\n    st.x *= u_resolution.x/u_resolution.y;\n    vec2 rt = st - vec2(0.5);\n\tst *= 4.5;\n    mouse *= 4.5;\n    rt = vec2(length(rt) * 10., atan(rt.y, rt.x));\n    float time = u_time;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    //float fbm0 = fbm(st+vec2(0.490,0.020)+fbm(st+vec2(-0.240,0.090)+fbm(st+10.*vec2(0.680,0.310))));\n    float fbm1 = fbm(st*0.65+time/50.);\n    float fbm2 = fbm(st*fbm1 + time/25. - cos(time/100.)/1.);\n    float fbm3 = fbm(st + fbm2 + vec2(-time/15., time / 15.));\n    float fbm4 = fbm(0.5*sin(st*2.) + fbm3 + time/2.);\n\n\n    //different color variations happening over here!\n    color = vec3(1.);\n    color = mix(vec3(0.4314, 0.0, 0.0), vec3(0.251, 0.1176, 0.502), fbm1);\n    color = mix(color, vec3(1.0, 0.3412, 0.0157), fbm2);\n    color = mix(color, vec3(0.0, 0.0, 0.0), fbm3);\n    // color = mix(color, vec3(0.4941, 0.0, 0.0), .5*fbm4);\n    color *= 1.8;\n\n    //comment out the following line to remove the mouse functionality\n    // if (!(u_mouse.x <= 25. || u_mouse.x >= u_resolution.x -25. || u_mouse.y <= 25. || u_mouse.y >= u_resolution.y - 25.)) {\n    //     color = mix(color, color / 2., 1.-smoothstep(0.7, 1., 0.8*length(st-mouse)+fbm3));\n    //     //color *= mix(vec3(0.0, 0.0, 0.0), vec3(1.) , smoothstep(0.9, 1., 0.8*length(st-mouse)+fbm3));\n    // }\n\n    // color = mix(color, vec3(0.0, 0.0, 0.0),1. - step(0.1, (length(st-mouse))));\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "fbm_ow.frag",
        "data": "// fbm_practice.frag\n// working on some fractal brownian motion\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(1.234,56.789)))*\n        123456.789);\n}\n\n//noise function by interpolating between corners of square\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of square\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define ITERATIONS 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float val = 0.;\n    float amplitude = .5;\n    float frequency = 1.5; \n    float amp_scale = .5; //should be less than 1\n    float freq_scale = 2.; //should be greater than 1\n    \n    //number of \"octaves\" / scaled waves\n    for (int i = 0; i < ITERATIONS; i++) {\n        val += amplitude * noise(st * frequency);\n        frequency *= freq_scale;\n        amplitude *= amp_scale;\n    }\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec2 mouse = u_mouse / u_resolution;\n    mouse.x *= u_resolution.x/u_resolution.y;\n    st.x *= u_resolution.x/u_resolution.y;\n\tst *= 4.5;\n    mouse *= 4.5;\n\n    float time = u_time;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    //float fbm0 = fbm(st+vec2(0.490,0.020)+fbm(st+vec2(-0.240,0.090)+fbm(st+10.*vec2(0.680,0.310))));\n    float fbm1 = fbm(st+5.*vec2(-0.5,1.5)*.05*cos(0.125*time) - 2.*vec2(0.25, 0.1)*time);\n    float fbm2 = fbm(st+vec2(-0.240,0.090)+0.5*fbm1+ vec2(-0.5 * time, 0.3*sin(st.y+time+noise(st))));\n    float fbm3 = fbm(st+vec2(0.490,0.020)*fbm2 + vec2(0.5, 0.5)*0.1*sin(1.5*time) + 0.1*time + fbm1);\n     \n    //different color variations happening over here!\n    color += mix(vec3(0.8627, 0.502, 0.0863), vec3(0.0706, 0.2784, 0.098), fbm1);\n    color += mix(vec3(0.9176, 0.4431, 0.4431), vec3(0.6039, 0.0471, 0.5294), fbm2);\n    color *= mix(color, vec3(0.0, 0.0, 0.00), clamp(fbm3, 0., 1.));\n    color *= .8;\n    //comment out the following line to remove the mouse functionality\n    if (!(u_mouse.x <= 25. || u_mouse.x >= u_resolution.x -25. || u_mouse.y <= 25. || u_mouse.y >= u_resolution.y - 25.)) {\n        color -= mix(vec3(0.0, 0.0, 0.0), vec3(.9) , 1.-smoothstep(0.7, 1., 0.8*length(st-mouse)+fbm3));\n        //color *= mix(vec3(0.0, 0.0, 0.0), vec3(1.) , smoothstep(0.9, 1., 0.8*length(st-mouse)+fbm3));\n    }\n\n    // color = mix(color, vec3(0.0, 0.0, 0.0),1. - step(0.1, (length(st-mouse))));\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "cellular_noise.frag",
        "data": "//cellular_noise.frag\n//playing with cellular noise and some\n//REALLY annoying \n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define PI 3.141592653589793\n\nvec2 random2( vec2 p) {\n    p.y = mod(p.y, 10.);\n    return fract(sin(\n        vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)))\n                    )*43758.5453);\n}\n\nvec3 hardlines_voronoi(vec2 st) {\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    float mdist = 8.0;\n    vec2 mdiff;\n    \n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 rPoint = random2(n + ipos);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            if(dist < mdist) {\n                mdist = dist;\n                mdiff = diff;\n            } \n\t\t}\n    }\n    \n    mdist = 8.0;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 rPoint = random2(n + ipos);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            \n            if(dot(mdiff-diff, mdiff-diff) > 0.0001) {\n                mdist = min(mdist, abs(dot(0.5*(mdiff+diff), normalize(mdiff-diff))));\n            }\n\t\t}\n    }\n    return vec3(mdist, mdiff);\n}\n\nvec3 hardlines_voronoi_with_point(in vec2 st, in float scale, in vec2 point) {\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    float mdist = 8.0;\n    vec2 mdiff;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n        \tvec2 n = vec2(float(i), float(j));\n            vec2 inp = n+ipos;\n            inp.y = mod(inp.y, scale);\n            vec2 rPoint = random2(inp);\n            //rPoint = 0.5+0.5 * sin(u_time+2.*PI*rPoint);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            if(dist < mdist) {\n                mdist = dist;\n                mdiff = diff;\n            } \n\t\t}\n    }\n\n    for(int i = -1; i <= 1; i++) {\n        vec2 pointDiff = point + vec2(0., scale*float(i)) - ipos - fpos;\n        if(dot(pointDiff, pointDiff) < mdist) {\n            mdist = dot(pointDiff, pointDiff);\n            mdiff = pointDiff;\n        }\n    }\n    \n    mdist = 8.0;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 inp = n+ipos;\n            inp.y = mod(inp.y, scale);\n            vec2 rPoint = random2(inp);\n            //rPoint = 0.5+0.5 * sin(u_time+2.*PI*rPoint);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            \n            if(dot(mdiff-diff, mdiff-diff) > 0.0001) {\n                mdist = min(mdist, abs(dot(0.5*(mdiff+diff), normalize(mdiff-diff))));\n            }\n\t\t}\n    }\n    return vec3(mdist, mdiff);\n}\n\nvec2 transform(in vec2 st, float scale, vec2 pre_translate, vec2 post_translate) {\n    st -= pre_translate;\n    vec2 uv = vec2(length(st), atan(st.y, st.x));\n    //if(st.x < 0.) uv.y += PI;\n    //uv.y = 0.;\n    uv.y = uv.y/2./PI + 0.5;\n    //uv.y = .5-.5*cos(2.*uv.y*PI);\n    //uv.y = 1.-pow((2.*(uv.y-0.5)),2.);\n    uv *= scale;\n    //uv.y = mod(uv.y, scale);\n    uv.r = 2. * sin(uv.r);\n    uv += post_translate;\n    return uv;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n    const float SCALE = 10.;\n    vec2 mouse = u_mouse / u_resolution;\n    mouse.x *= u_resolution.x / u_resolution.y;\n    vec3 color = vec3(0.0);\n    \n//     st -= 0.5;\n    \n//     st = vec2(length(st), atan(st.y, st.x));\n//     st.y = st.y/2./PI + 0.5;\n//     st *= SCALE;\n    st = transform(st, SCALE, vec2(0.5), vec2(u_time*0.75, u_time*0.25));\n\tmouse = transform(mouse, SCALE, vec2(0.5), vec2(u_time*0.75, u_time*0.25));\n    \n\tvec3 voronoi = hardlines_voronoi_with_point(st, SCALE, mouse);\n\n    color += vec3(step(voronoi.x, 0.02));\n    //color *= mix(color, vec3(0.2902, 0.4824, 0.9608), voronoi.x);\n\n//     // Show isolines\n//     color -= abs(sin(80.0*m_dist))*0.07;\n\n\t//color += step(length(voronoi.yz), 0.02);\n    \n   //color.r += step(0.98, fract(st.x)) + step(0.98, fract(st.y));// + step(st.y, 4.936);\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "mandelbrot_set.frag",
        "data": "//mandelbrot_set.frag\n//displays the mandelbrot set\n//move mouse across screen to zoom in\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.141592653589793\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\n\nmat2 rotate(float theta) {\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\nvec2 multiply_complex(vec2 z1, vec2 z2) {\n    return vec2(z1.x*z2.x-z1.y*z2.y, z1.y*z2.x+z1.x*z2.y);\n}\n\n#define ITERATIONS 500\nfloat mandelbrot(in vec2 st) {\n    vec2 z = vec2(0.);\n    for(int i = 0; i < ITERATIONS; i++) {\n        if(dot(z,z) > 5.) return float(i);\n        z = multiply_complex(z,z) + st;\n    }\n    return 0.;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy / u_resolution;\n    st.x *= u_resolution.x / u_resolution.y;\n    vec2 mouse = u_mouse / u_resolution;\n    mouse.x *= u_resolution.x / u_resolution.y;\n    mouse.x *= 6.;\n    st -= vec2(.7-.73/3., .5+.23/3.);\n    st *= 3. * exp(-mouse.x);\n    //st *= rotate(u_time * 0.1);\n    float ms = mandelbrot(st+vec2(-.715,0.23));\n\n    vec3 color = vec3(0.);\n    color = vec3(step(0.02, ms));\n    color *= mix(vec3(1.0, 0.4667, .0), vec3(0.2667, 0.0, 1.0), 1.0 - ms / (float(ITERATIONS) / 5.));\n\n    //color += step(-0.002, st.x) * step(st.x, 0.002) + step(-0.002, st.y) * step(st.y, 0.002);\n\n    gl_FragColor = vec4(color, 1.0);\n}"
    },
    {
        "name": "fbm_mosaic.frag",
        "data": "// fbm_practice.frag\n// working on some fractal brownian motion\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(1.234,56.789)))*\n        123456.789);\n}\n\n//noise function by interpolating between corners of square\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of square\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define ITERATIONS 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float val = 0.;\n    float amplitude = .5;\n    float frequency = 1.5; \n    float amp_scale = .5; //should be less than 1\n    float freq_scale = 2.; //should be greater than 1\n    \n    //number of \"octaves\" / scaled waves\n    for (int i = 0; i < ITERATIONS; i++) {\n        val += amplitude * noise(st * frequency);\n        frequency *= freq_scale;\n        amplitude *= amp_scale;\n    }\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec2 mouse = u_mouse.xy / u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n    mouse.x *= u_resolution.x/u_resolution.y;\n    mouse *= 4.5;\n\tst *= 4.5;\n\n    float time = u_time;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    //float fbm0 = fbm(st+vec2(0.490,0.020)+fbm(st+vec2(-0.240,0.090)+fbm(st+10.*vec2(0.680,0.310))));\n    float fbm1 = fbm(st+5.*vec2(-0.5,1.5)*.05*cos(0.125*time) - 2.*vec2(0.25, 0.1)*time);\n    float fbm2 = fbm(st+vec2(-0.240,0.090)+0.5*fbm1+ vec2(-0.5 * time, 0.3*sin(st.y+time+noise(st))));\n    float fbm3 = fbm(st+vec2(0.490,0.020)*fbm2 + vec2(0.5, 0.5)*0.1*sin(1.5*time) + 0.1*time + fbm1);\n     \n    //different color variations happening over here!\n    color += mix(vec3(0.0863, 0.8627, 0.7451), vec3(0.0706, 0.2784, 0.098), fbm1);\n    color += mix(vec3(0.9176, 0.4431, 0.4431), vec3(0.6039, 0.0471, 0.5294), fbm2);\n    color *= mix(color, vec3(0.0392, 0.149, 0.4471), fbm3);\n\n        //comment out the following line to remove the mouse functionality\n    if (!(u_mouse.x <= 25. || u_mouse.x >= u_resolution.x -25. || u_mouse.y <= 25. || u_mouse.y >= u_resolution.y - 25.)) {\n        color += mix(vec3(0.0, 0.0, 0.0), vec3(.3) , 1.-smoothstep(0.7, 1., 0.8*length(st-mouse)+fbm3));\n        //color *= mix(vec3(0.0, 0.0, 0.0), vec3(1.) , smoothstep(0.9, 1., 0.8*length(st-mouse)+fbm3));\n    }\n\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "fbm_practice.frag",
        "data": "// fbm_practice.frag\n// working on some fractal brownian motion\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(1.234,56.789)))*\n        123456.789);\n}\n\n//noise function by interpolating between corners of square\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of square\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define ITERATIONS 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float val = 0.;\n    float amplitude = .5;\n    float frequency = 1.5; \n    float amp_scale = .5; //should be less than 1\n    float freq_scale = 2.; //should be greater than 1\n    \n    //number of \"octaves\" / scaled waves\n    for (int i = 0; i < ITERATIONS; i++) {\n        val += amplitude * noise(st * frequency);\n        frequency *= freq_scale;\n        amplitude *= amp_scale;\n    }\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n\tst *= 4.5;\n\t\n    vec3 color = vec3(0.0);\n    //float fbm0 = fbm(st+vec2(0.490,0.020)+fbm(st+vec2(-0.240,0.090)+fbm(st+10.*vec2(0.680,0.310))));\n    float fbm1 = fbm(st+10.*vec2(0.680,0.310) - vec2(0.3, 0.1)*u_time);\n    float fbm2 = fbm(st+vec2(-0.240,0.090)+fbm1 + vec2(0.3*sin(st.x+u_time+noise(st)), 0.5 * u_time));\n    float fbm3 = fbm(st+vec2(0.490,0.020) + fbm2+0.3*u_time);\n     \n    //change this value to see different color saturations\n    //right now, 0, 1 or not those :D\n    //I don't *fully* understand these--mostly just playing with values--but I'm getting there\n    int color_choice = 3;\n    if(color_choice == 0) {\n        //color option 1\n        color += mix(vec3(0.), vec3(0.980,0.318,0.004), fbm1);\n        color += mix(vec3(0.), vec3(0.3216, 0.3882, 0.349), fbm2);\n        color += mix(vec3(0.276,0.756,1.000), vec3(0.002,0.000,0.170), fbm3);\n    }\n    else if(color_choice == 1) {\n        //color option 2\n        color = mix(vec3(0.276,0.756,1.000), vec3(0.980,0.318,0.004), fbm1);\n        color += mix(color, vec3(0.3216, 0.3882, 0.349), fbm2);\n        color *= mix(color, vec3(0.002,0.000,0.170), fbm3);\n    }\n    else if(color_choice == 2) {\n        color = mix(vec3(1.0, 0.2902, 0.4667), vec3(0.9804, 0.4745, 0.0039), fbm1);\n        color = mix(color, vec3(0.6157, 0.9765, 0.7412), fbm2);\n        color = mix(color, vec3(0.149, 0.0824, 0.4118), fbm3);\n    }\n    else {\n        color -= mix(vec3(1.0, 0.2902, 0.4667), vec3(0.9804, 0.4745, 0.0039), fbm1);\n        color += mix(color, vec3(1.0, 1.0, 1.0), fbm2);\n        color *= mix(color, vec3(0.2353, 0.0706, 0.4353), fbm3);\n    }\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    }
]