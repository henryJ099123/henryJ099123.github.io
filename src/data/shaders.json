[
    {
        "name": "noise.frag",
        "data": "//random_texture.frag\n//simply displays a random texture using heavily compressed sine waves\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//function to create noise\nfloat noise (in vec2 st) {\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n\n    float a = random(ipos);\n    float b = random(ipos + vec2(1.0, 0.0));\n    float c = random(ipos + vec2(1.0, 1.0));\n    float d = random(ipos + vec2(0.0, 1.0));\n\n    vec2 u = smoothstep(0.0, 1.0, fpos);\n\n    //bilinear interpolation - would work the same if we did two vertical\n    //      linear interpolations first and horizontally connected them too\n    float r_dc = mix(d, c, u.x);\n    float r_ab = mix(a, b, u.x);\n    float p = mix(r_ab, r_dc, u.y);\n\n    return p;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy / u_resolution;\n    st.x *= u_resolution.x / u_resolution.y;\n\n    st *= 6.0;\n\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n\n    float a = random(ipos);\n    float b = random(ipos + vec2(1.0, 0.0));\n    float c = random(ipos + vec2(1.0, 1.0));\n    float d = random(ipos + vec2(0.0, 1.0));\n\n    vec2 u = smoothstep(0.0, 1.0, fpos);\n\n    //float ret = mix(a, b, fpos.x) * mix(b, c, fpos.y) * mix(d, c, fpos.x) * mix(a, d, fpos.y);\n    // float ret = mix(a, b, u.x) + (d - a) * u.y * (1.0 - u.x) + (c - b) * u.x * u.y;\n    // ret = a-a*u.x+b*u.x+d*u.y-a*u.y+(a+c-d-b)*u.x*u.y; \n\n    //bilinear interpolation -- explanation of the math to get here below\n    float ret = (1.-u.x)*(1.-u.y)*a + u.x*(1.-u.y)*b + (1.-u.x)*u.y*d + u.x*u.y*c;\n\n    //here is the breakdown of how to get this:\n    //************ BREAKDOWN OF BILINEAR INTERPOLATION ********//\n    // square:\n    //          D ------ C\n    //           |      |\n    //           |      |\n    //           |      |\n    //         A  ------ B\n    //first, linearly interpolate between A, B to find a point r_ab on segment AB\n    //then, linearly interpolate between D, C to find a point r_dc on segment DC\n    //these first two linear interpolations are using the x-axis to interpolate\n    //lastly, we linearly interpolate between these two points we found (r_ab, r_dc)\n    //      along the y-axis\n    //this produces a linear interpolation between all four points of the square\n    //interpolating all the values inside the square based on the four corners!!\n    //************ BREAKDOWN OF BILINEAR INTERPOLATION OVER ********//\n\n    float r_dc = mix(d, c, u.x);\n    float r_ab = mix(a, b, u.x);\n    float p = mix(r_ab, r_dc, u.y);\n\n    vec3 color = vec3(noise(st));\n\n    gl_FragColor = vec4(color, 1.0);\n}"
    },
    {
        "name": "rainbow.frag",
        "data": "//fragment shader which draws a moving rainbow to the screen\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nvec3 colorA = vec3(0.149,0.141,0.912);\nvec3 colorB = vec3(1.000,0.833,0.224);\nvec3 white = vec3(1.0);\n\nfloat plot (vec2 st, float pct){\n  return  smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.01, st.y);\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec3 color = vec3(0.0);\n\n    vec3 pct;\n    \n    float adv = st.x + u_time;\n\n    pct.r = clamp(0.5 + cos(2.0*PI*adv), 0.0, 1.0);\n    pct.g = clamp(0.5 + sin(2.0*PI*(adv-1.0/12.0)), 0.0, 1.0);\n    pct.b = clamp(0.5 + sin(2.0*PI*(adv - 5.0/12.0)), 0.0, 1.0);\n\n    // pct.r = smoothstep(0.0,1.0, st.x);\n    // pct.g = sin(st.x*PI);\n    // pct.b = pow(st.x,0.5);\n\tcolor = pct;\n    //color = mix(colorA, colorB, pct);\n\n    // Plot transition lines for each channel\n//    color = mix(color,vec3(1.0,0.0,0.0),plot(st,pct.r));\n  //  color = mix(color,vec3(0.0,1.0,0.0),plot(st,pct.g));\n    //color = mix(color,vec3(0.0,0.0,1.0),plot(st,pct.b));\n\n    gl_FragColor = vec4(color,1.0);\n}\n\n"
    },
    {
        "name": "circle_noise.frag",
        "data": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.141592653589793\n\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform float u_time;\n\n//theta is in radians!\nmat2 rotate(float theta) {\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\n//pseudo-random code\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//function to create noise\nfloat noise (in vec2 st) {\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n\n    float a = random(ipos);\n    float b = random(ipos + vec2(1.0, 0.0));\n    float c = random(ipos + vec2(1.0, 1.0));\n    float d = random(ipos + vec2(0.0, 1.0));\n\n    vec2 u = smoothstep(0.0, 1.0, fpos);\n\n    //bilinear interpolation - would work the same if we did two vertical\n    //      linear interpolations first and horizontally connected them too\n    float r_dc = mix(d, c, u.x);\n    float r_ab = mix(a, b, u.x);\n    float p = mix(r_ab, r_dc, u.y);\n\n    return p;\n}\n\n//draws a ring from center with inner radius _inner_rad and width _width\nfloat ring(in vec2 _st, in float _inner_rad, in float _width) {\n    return step(_inner_rad, length(_st)) * step(length(_st), _inner_rad + _width);\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy / u_resolution;\n    st.x *= u_resolution.x / u_resolution.y;\n\n    vec2 mouse = u_mouse / u_resolution;\n\n    //centers the coordinate space\n    st -= vec2(0.5);\n\n    //converts to polar\n    vec2 polar = vec2(length(st), atan(st.y, st.x));\n\n    //input for noise\n    vec2 noise_input = polar * 25.;\n    noise_input.r += 2. * u_time; //will allow some scaling with time\n\n    float pct = ring(st, 0.1 + 0.2 * noise(noise_input),  0.2 * noise(noise_input));\n\n    vec3 color = pct * mix(vec3(mouse.x, mouse.y, 1.0), vec3(1.0), 0.5);\n    \n    //uncomment to see the gradient the mouse moves over\n    //color = vec3(st.x + 0.5, st.y + 0.5, 1.0);\n\n    gl_FragColor = vec4(color, 1.0);\n}"
    },
    {
        "name": "circle_field.frag",
        "data": "//circle_fields.frag\n//some more cool circle animations\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nvoid main(){\n  vec2 st = gl_FragCoord.xy/u_resolution.xy;\n  st.x *= u_resolution.x/u_resolution.y;\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n\n  // Make the distance field\n  d = length( abs(st) - 0.3);\n   //d = length( min(abs(st)-.3,0.) );\n  // d = length( max(abs(st)-.3,0.) );\n\n  // Visualize the distance field\n     color =  vec3(sin(d*15. - 5.*u_time));\n     color = step(0.746, color);\n     color = 1.0 - color;\n    //simple masking!\n    vec3 color_white = step(0.001, color);\n    vec3 color_black = 1.0 - color_white;\n    color_white *= vec3(0.5 + 0.5*sin(u_time), 0.5 + 0.5*cos(u_time), 0.5 + 0.5*cos(-u_time));\n    color_black *= vec3(0.5 + 0.5*cos(2.0*u_time), 0.5 + 0.5*sin(2.0*u_time), 0.5 + 0.5*cos(3.0*u_time));\n    color = color_white + color_black;\n  //color = vec3(fract(d*10.));\n  gl_FragColor = vec4(color, 1.0);\n\n  // Drawing with the distance field\n  // gl_FragColor = vec4(vec3( step(.3,d) ),1.0);\n  // gl_FragColor = vec4(vec3( step(.3,d) * step(d,.4)),1.0);\n  // gl_FragColor = vec4(vec3( smoothstep(.3,.4,d)* smoothstep(.6,.5,d)) ,1.0);\n}\n\n"
    },
    {
        "name": "cells_wall.frag",
        "data": "//cellular_noise.frag\n//playing with cellular noise and some\n//REALLY annoying \n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define PI 3.141592653589793\n\nvec2 random2( vec2 p) {\n    p.y = mod(p.y, 10.);\n    return fract(sin(\n        vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)))\n                    )*43758.5453);\n}\n\nvec3 hardlines_voronoi(vec2 st) {\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    float mdist = 8.0;\n    vec2 mdiff;\n    \n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 rPoint = random2(n + ipos);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            if(dist < mdist) {\n                mdist = dist;\n                mdiff = diff;\n            } \n\t\t}\n    }\n    \n    mdist = 8.0;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 rPoint = random2(n + ipos);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            \n            if(dot(mdiff-diff, mdiff-diff) > 0.0001) {\n                mdist = min(mdist, abs(dot(0.5*(mdiff+diff), normalize(mdiff-diff))));\n            }\n\t\t}\n    }\n    return vec3(mdist, mdiff);\n}\n\nvec3 hardlines_voronoi_with_point(in vec2 st, in float scale, in vec2 point) {\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    float mdist = 8.0;\n    vec2 mdiff;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n        \tvec2 n = vec2(float(i), float(j));\n            vec2 inp = n+ipos;\n            inp.y = mod(inp.y, scale);\n            vec2 rPoint = random2(inp);\n            //rPoint = 0.5+0.5 * sin(u_time+2.*PI*rPoint);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            if(dist < mdist) {\n                mdist = dist;\n                mdiff = diff;\n            } \n\t\t}\n    }\n\n    for(int i = -1; i <= 1; i++) {\n        vec2 pointDiff = point + vec2(0., scale*float(i)) - ipos - fpos;\n        if(dot(pointDiff, pointDiff) < mdist) {\n            mdist = dot(pointDiff, pointDiff);\n            mdiff = pointDiff;\n        }\n    }\n    \n    mdist = 8.0;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 inp = n+ipos;\n            inp.y = mod(inp.y, scale);\n            vec2 rPoint = random2(inp);\n            //rPoint = 0.5+0.5 * sin(u_time+2.*PI*rPoint);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            \n            if(dot(mdiff-diff, mdiff-diff) > 0.0001) {\n                mdist = min(mdist, abs(dot(0.5*(mdiff+diff), normalize(mdiff-diff))));\n            }\n\t\t}\n    }\n    return vec3(mdist, mdiff);\n}\n\nvec2 transform(in vec2 st, float scale, vec2 pre_translate, vec2 post_translate) {\n    st -= pre_translate;\n    vec2 uv = st;\n    // vec2 uv = vec2(length(st), atan(st.y, st.x));\n    //if(st.x < 0.) uv.y += PI;\n    //uv.y = 0.;\n    // uv.y = uv.y/2./PI + 0.5;\n    //uv.y = .5-.5*cos(2.*uv.y*PI);\n    //uv.y = 1.-pow((2.*(uv.y-0.5)),2.);\n    uv *= scale;\n    // uv.y = mod(uv.y, scale);\n    uv.x = 2. * cos(uv.x);\n    // uv.y = length(uv);\n    // uv.y = 1. * sin(uv.y);\n    uv += post_translate;\n    return uv;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n    const float SCALE = 10.;\n    vec2 mouse = u_mouse / u_resolution;\n    mouse.x *= u_resolution.x / u_resolution.y;\n    // vec3 color = vec3(0.2745, 0.0118, 0.0118);\n    vec3 color = vec3(0.);\n    \n//     st -= 0.5;\n    \n//     st = vec2(length(st), atan(st.y, st.x));\n//     st.y = st.y/2./PI + 0.5;\n//     st *= SCALE;\n    st = transform(st, SCALE, vec2(0.5), vec2(u_time, u_time) * vec2(.4, 0.15));\n\tmouse = transform(mouse, SCALE, vec2(0.5), vec2(u_time, u_time) * vec2(0.4, 0.15));\n    \n\tvec3 voronoi = hardlines_voronoi_with_point(st, SCALE, mouse);\n\n    color += vec3(step(voronoi.x, 0.02));\n    // color += vec3(smoothstep(0.02, 0., voronoi.x));\n    //\n    // color = mix(color, vec3(1.0, 0.2353, 0.0), voronoi.z);\n\n//     // Show isolines\n    //color -= abs(sin(80.0*m_dist))*0.07;\n\n\t//color += step(length(voronoi.yz), 0.02);\n    \n   //color.r += step(0.98, fract(st.x)) + step(0.98, fract(st.y));// + step(st.y, 4.936);\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "random.frag",
        "data": "// random.frag\n// move mouse left-right to change threshold of cell shown\n//move mouse up-down to mix color between color1 and color2\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid main() {\n    vec3 color1 = vec3(1., 0., 0.5);\n    vec3 color2 = vec3(0.5, 0.3, 1.);\n    \n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x / u_resolution.y;\n\tvec2 mouse = u_mouse / u_resolution;\n    st.x *= 50.0; // Scale the coordinate system by 10\n    st.y *= 50.;\n    \n    float offset = u_time * sin(5.*random(vec2(floor(st.y))));\n    \n    st.x += offset * 20.;\n    vec2 ipos = floor(vec2(st.x, st.y));  // get the integer coords\n    vec2 fpos = fract(st);  // get the fractional coords\n\n    // Assign a random value based on the integer coord\n    float rand = random(ipos);\n    rand = 1.0 - rand*step(mouse.x, rand);\n    //vec3 color = rand * vec3(abs(sin(mouse.y)), abs(cos(mouse.y)), 1.0);\n    vec3 color = rand * mix(color1, color2, mouse.y);\n    // Uncomment to see the subdivided grid\n    // color = vec3(fpos,0.0);\n\n    gl_FragColor = vec4(color,1.0);\n}\n\n"
    },
    {
        "name": "fbm_orange.frag",
        "data": "// fbm_practice.frag\n// working on some fractal brownian motion\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(1.234,56.789)))*\n        123456.789);\n}\n\nvec2 sin2(in float x, in float y) {\n    return vec2(sin(x), sin(y));\n}\n\n//noise function by interpolating between corners of square\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of square\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define ITERATIONS 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float val = 0.;\n    float amplitude = .5;\n    float frequency = 1.5; \n    float amp_scale = .5; //should be less than 1\n    float freq_scale = 2.; //should be greater than 1\n    \n    //number of \"octaves\" / scaled waves\n    for (int i = 0; i < ITERATIONS; i++) {\n        val += amplitude * noise(st * frequency);\n        frequency *= freq_scale;\n        amplitude *= amp_scale;\n    }\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec2 mouse = u_mouse / u_resolution;\n    mouse.x *= u_resolution.x/u_resolution.y;\n    st.x *= u_resolution.x/u_resolution.y;\n    vec2 rt = st - vec2(0.5);\n\tst *= 4.5;\n    mouse *= 4.5;\n    rt = vec2(length(rt) * 10., atan(rt.y, rt.x));\n    float time = u_time;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    //float fbm0 = fbm(st+vec2(0.490,0.020)+fbm(st+vec2(-0.240,0.090)+fbm(st+10.*vec2(0.680,0.310))));\n    float fbm1 = fbm(st*0.65+time/10.);\n    float fbm2 = fbm(st*fbm1 + time/5. - cos(time/10.));\n    float fbm3 = fbm(st + fbm2 + vec2(-time/15., time / 15.));\n    float fbm4 = fbm(0.5*sin(st*2.) + fbm3 + time/2.);\n\n\n    //different color variations happening over here!\n    color = vec3(1.);\n    color = mix(vec3(0.4314, 0.0, 0.0), vec3(0.0, 1.0, 0.8353), fbm1);\n    color = mix(color, vec3(1.0, 0.2824, 0.0), fbm2);\n    color = mix(color, vec3(0.0, 0.0, 0.0), fbm3);\n    // color = mix(color, vec3(0.4941, 0.0, 0.0), .5*fbm4);\n    color *= 1.8;\n\n    //comment out the following line to remove the mouse functionality\n    // if (!(u_mouse.x <= 25. || u_mouse.x >= u_resolution.x -25. || u_mouse.y <= 25. || u_mouse.y >= u_resolution.y - 25.)) {\n    //     color = mix(color, color / 2., 1.-smoothstep(0.7, 1., 0.8*length(st-mouse)+fbm3));\n    //     //color *= mix(vec3(0.0, 0.0, 0.0), vec3(1.) , smoothstep(0.9, 1., 0.8*length(st-mouse)+fbm3));\n    // }\n\n    // color = mix(color, vec3(0.0, 0.0, 0.0),1. - step(0.1, (length(st-mouse))));\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "square_rect.frag",
        "data": "//square_rect.frag\n//contains some functions to draw rectangles/squares on a shader\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n\n//creates a square centered in frame with border\nvec3 square_center(in vec2 v, float border, vec3 fill, vec3 border_fill) {\n\tvec2 bl = step(vec2(border), v);\n    //bl = smoothstep(0.0, border, v);\n    float pct = bl.x * bl.y;\n    \n    vec2 tr = step(vec2(border), 1.0 - v);\n    //tr = smoothstep(0.0, border, 1.0-v);\n    pct *= tr.x * tr.y;\n    \n    //returns 0 if on border, returns 1 if not\n    float is_on_border = step(0.01, pct);\n    \n\tvec3 color = vec3(pct);\n    \n    //fills the inner part of the square\n    color *= fill;\n    \n    //fills the border by NOT adding the color if it is in the middle\n    color += border_fill * (1.0 - is_on_border);\n    \n    return color;\n}\n\n//creates a rectangle with top/bottom letterboxing of length border_y \n//and right/left letterboxing with length border_x\nvec3 rectangle_center(in vec2 v, float border_x, float border_y, vec3 fill, vec3 border_fill) {\n    float left = step(border_x, v.x);\n    float bottom = step(border_y, v.y);\n    float right = step(border_x, 1.0-v.x);\n    float top = step(border_y, 1.0-v.y);\n    //bl = smoothstep(0.0, border, v);\n    //float pct = bl.x * bl.y;\n    \n    float pct = left * bottom * right * top;\n    \n    //vec2 tr = step(vec2(border), 1.0 - v);\n    //tr = smoothstep(0.0, border, 1.0-v);\n    //pct *= tr.x * tr.y;\n    \n    //returns 0 if on border, returns 1 if not\n    float is_on_border = step(0.01, pct);\n    \n\tvec3 color = vec3(pct);\n    \n    //fills the inner part of the square\n    color *= fill;\n    \n    //fills the border by NOT adding the color if it is in the middle\n    color += border_fill * (1.0 - is_on_border);\n    \n    return color;\n}\n\n//draws a square of color 'fill' and side length 'side' on the screen\n//bottom-left coordinate is 'coord'\nvec3 square_coord(in vec2 v, vec2 coord, float side, vec3 fill) {\n    float left = step(coord.x, v.x);\n    float right = 1.0 - step(coord.x + side, v.x);\n    float bottom = step(coord.y, v.y);\n    float top = 1.0 - step(coord.y + side, v.y);\n    \n    float pct = left * bottom * top * right;\n    \n    vec3 color = vec3(pct);\n    \n    return color * fill;\n}\n//draws a square of color 'fill', width 'side_x', and length 'side_y' on the screen\n//bottom-left coordinate is 'coord'\nvec3 rect_coord(in vec2 v, vec2 coord, float side_x, float side_y, vec3 fill) {\n    float left = step(coord.x, v.x);\n    float right = 1.0 - step(coord.x + side_x, v.x);\n    float bottom = step(coord.y, v.y);\n    float top = 1.0 - step(coord.y + side_y, v.y);\n    \n    float pct = left * bottom * top * right;\n    \n    vec3 color = vec3(pct);\n    \n    return color * fill;\n}\n\nvoid main(){\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec3 color = vec3(0.0); //set background color\n    \n    //color = square_center(st, 0.044, vec3(0.942,0.995,0.003), vec3(0.429,0.595,0.274));\n    //color = rectangle_center(st, 0.292, 0.092, vec3(0.522,1.000,0.333), vec3(0.780,0.638,0.423));\n    \n    color += rect_coord(st, vec2(0.03,0.72), 0.100, 0.25, vec3(0.830,0.000,0.000));\n    color += rect_coord(st, vec2(0.16,0.72), 0.150, 0.25, vec3(0.830,0.000,0.000));\n    color += rect_coord(st, vec2(0.16+.15+.03,0.720), 0.45, 0.25, vec3(0.995,0.904,0.551));\n    color += square_coord(st, vec2(0.16+.15+.03+.45+.03,0.720), 0.25, vec3(0.995,0.904,0.551));\n    color += rect_coord(st, vec2(0.03,0.72-.28), 0.100, 0.25, vec3(0.830,0.000,0.000));\n    color += rect_coord(st, vec2(0.16,0.72-.28), 0.150, 0.25, vec3(0.830,0.000,0.000));\n    color += rect_coord(st, vec2(0.16+.15+.03,0.720-.28), 0.45, 0.25, vec3(0.995,0.904,0.551));\n    color += square_coord(st, vec2(0.16+.15+.03+.45+.03,0.72-.28), 0.25, vec3(0.000,0.101,0.995));\n    color += rect_coord(st, vec2(0.030,-0.090), 0.28, .5, vec3(0.995,0.904,0.551));\n    color += rect_coord(st, vec2(0.060+.28,-0.090), 0.45, .5, vec3(0.995,0.904,0.551));\n    color += rect_coord(st, vec2(0.060+.28+.48,-0.090), 0.5, .5, vec3(0.995,0.904,0.551));\n    \n    gl_FragColor = vec4(color,1.0);\n}\n\n"
    },
    {
        "name": "fbm_clouds.frag",
        "data": "// fbm_practice.frag\n// working on some fractal brownian motion\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(1.234,56.789)))*\n        123456.789);\n}\n\n//noise function by interpolating between corners of square\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of square\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define ITERATIONS 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float val = 0.;\n    float amplitude = .5;\n    float frequency = 1.5; \n    float amp_scale = .5; //should be less than 1\n    float freq_scale = 2.; //should be greater than 1\n    \n    //number of \"octaves\" / scaled waves\n    for (int i = 0; i < ITERATIONS; i++) {\n        val += amplitude * noise(st * frequency);\n        frequency *= freq_scale;\n        amplitude *= amp_scale;\n    }\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n\tst *= 4.5;\n\n    float time = u_time;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    //float fbm0 = fbm(st+vec2(0.490,0.020)+fbm(st+vec2(-0.240,0.090)+fbm(st+10.*vec2(0.680,0.310))));\n    float fbm1 = fbm(st+5.*vec2(-0.5,1.5)*.05*cos(0.125*time) - 2.*vec2(0.25, 0.1)*time);\n    float fbm2 = fbm(st+vec2(-0.240,0.090)+0.5*fbm1+ vec2(-0.5 * time, 0.3*sin(st.y+time+noise(st))));\n    float fbm3 = fbm(st+vec2(0.490,0.020)*fbm2 + vec2(0.5, 0.5)*0.1*sin(1.5*time) + 0.1*time + fbm1);\n     \n    //different color variations happening over here!\n    int picker = 1;\n    if(picker == 0) {\n        color += mix(vec3(0.0863, 0.8627, 0.7451), vec3(0.0706, 0.2784, 0.098), fbm1);\n        color += mix(vec3(0.9176, 0.4431, 0.4431), vec3(0.6039, 0.0471, 0.5294), fbm2);\n        color *= mix(color, vec3(0.0392, 0.149, 0.4471), fbm3);\n    }\n    else {\n        color += mix(vec3(0.0863, 0.8627, 0.7451), vec3(0.0745, 0.2118, 0.2039), fbm1);\n        color += mix(color, vec3(0.6039, 0.0471, 0.5294), fbm2);\n        color *= mix(color, vec3(0.0392, 0.149, 0.4471), fbm3);\n    }\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "rect_noise.frag",
        "data": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.141592653589793\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n//pseudo-random code\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//function to create noise\nfloat noise (in vec2 st) {\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n\n    float a = random(ipos);\n    float b = random(ipos + vec2(1.0, 0.0));\n    float c = random(ipos + vec2(1.0, 1.0));\n    float d = random(ipos + vec2(0.0, 1.0));\n\n    vec2 u = smoothstep(0.0, 1.0, fpos);\n\n    //bilinear interpolation - would work the same if we did two vertical\n    //      linear interpolations first and horizontally connected them too\n    float r_dc = mix(d, c, u.x);\n    float r_ab = mix(a, b, u.x);\n    float p = mix(r_ab, r_dc, u.y);\n\n    return p;\n}\n\nfloat rect(in vec2 _st, in vec2 bot_left, float w, float h) {\n    return step(bot_left.x, _st.x) * step(_st.x, bot_left.x + w) * step(bot_left.y, _st.y) * step(_st.y, bot_left.y + h);\n}\n\nfloat fuzzy_rect(in vec2 _st, in vec2 bot_left, float w, float h, float fuzz) {\n    float left = smoothstep(bot_left.x, fuzz + bot_left.x, _st.x);\n    float right = 1.0 - smoothstep(bot_left.x - fuzz + w, bot_left.x + w, _st.x);\n    float bot = smoothstep(bot_left.y, fuzz + bot_left.y, _st.y);\n    float top = 1.0 - smoothstep(bot_left.y - fuzz + h, bot_left.y + h, _st.y);\n\n    return left * right * top * bot;\n}\n\n// float rect_texture(in vec2 _st, in vec2 bot_left, float w, float h, float fuzz) {\n//     float noisiness = 0.01 * sin(noise(_st * 10));\n\n//     float left = step(bot_left.x + 0.01 * sin(noise(_st * 10000.)), _st.x);\n//     float right = step(_st.x, bot_left.x + w);\n//     float top = step(_st.y, bot_left.y + h);\n//     float bot = step(bot_left.y, _st.y);\n\n//     return left * right * top * bot;\n// }\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy / u_resolution;\n    st.x *= u_resolution.x / u_resolution.y;\n\n    //different fuzziness adjustors using noise\n    float fuzz = 0.02 * noise(st * 100. * sin((u_time)));\n    float fuzz2 = 0.02 * noise(st * 100. + u_time);\n    float fuzz3 = (0.5 + 0.25 * sin(1.5 * u_time)) * noise(vec2(st.x * 100., st.y * 20. - 5. * u_time));\n\n    float ret = 0.0;\n\n    //left rectangle\n    ret = rect(st, vec2(0.1, 0.3) + fuzz, 0.2, 0.3);\n\n    //top right rectangle\n    ret += fuzzy_rect(st, vec2(0.7, 0.7), 0.2, 0.3, fuzz2);\n\n    //bottom middle rectangle\n    //stretchiness achieved by scaling the x and y coordinates differently\n    //see `fuzz3` above\n    ret += fuzzy_rect(st, vec2(0.5, 0.1), 0.1, fuzz3, 0.01);\n\n    vec3 color = vec3(0.0);\n    color += vec3(ret);// * vec3(noise(st * 10. * abs(sin(u_time))), noise(st * 20. - u_time), noise(st * 30. + u_time));\n    gl_FragColor = vec4(color, 1.0);\n}"
    },
    {
        "name": "ui.frag",
        "data": "//ui.frag\n//playing with circles, rings, and arcs, and rotation\n//has many reusable functions\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nmat2 rotate(float theta) {\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nfloat get_angle_normed(in vec2 uv) {\n    return atan(uv.y, uv.x) / 2.0 / PI + 0.5;\n}\n\nfloat circle(in vec2 _st, in float _radius) {\n    return 1.0 - step(_radius, length(_st));\n}\n\n// float circle_polar(in vec2 _rtheta, in float _radius) {\n//     return 1.0 - step(_radius, length(vec2()))\n// }\n\nfloat ring(in vec2 _st, in float _inner_rad, in float _width) {\n    return step(_inner_rad, length(_st)) * step(length(_st), _inner_rad + _width);\n}\n\n//_pct_arc is %age of circumference the arc contains\n//aka angle of the arc but in normed angle\nfloat arc(in vec2 _center, in float _rad, in float _thickness, in float _pct_arc, in float _rotation) {\n    _center *= rotate(_rotation);\n    float angle = get_angle_normed(_center);\n    \n    //radius outward\n    float is_on_arc = step(_rad, length(_center)) * step(length(_center), _rad + _thickness);\n    \n    //what's on the arc\n    is_on_arc *= step(angle, _pct_arc);\n    \n    return is_on_arc;\n}\n\n// float box(in vec2 _st, in vec2 _size){\n//     _size = vec2(0.5) - _size*0.5;\n//     vec2 uv = smoothstep(_size,\n//                         _size+vec2(0.001),\n//                         _st);\n//     uv *= smoothstep(_size,\n//                     _size+vec2(0.001),\n//                     vec2(1.0)-_st);\n//     return uv.x*uv.y;\n// }\n\n// float cross(in vec2 _st, float _size){\n//     return  box(_st, vec2(_size,_size/4.)) +\n//             box(_st, vec2(_size/4.,_size));\n// }\n\nvoid main(){\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x / u_resolution.y;\n\n    st -= vec2(0.5);\n    \n    //st *= rotate(0.5);\n    vec2 polar = vec2(0.0);\n    polar.r = length(st);\n    polar.g = get_angle_normed(st);\n    \n    vec3 color = vec3(0.0);\n\t\n\n//     st -= vec2(0.5);\n//     st = scale( vec2(sin(u_time)+1.0) ) * st;\n//     st += vec2(0.5);\n\n//     // Show the coordinates of the space on the background\n//     // color = vec3(st.x,st.y,0.0);\n\n//     // Add the shape on the foreground\n//     color += vec3(cross(st,0.2));\n    \n    //arcs in the center\n    color += vec3(arc(st, 0.08, 0.02, 0.2, 0.2));\n    color += vec3(arc(st, 0.08, 0.02, 0.2, PI+0.2));\n    color += vec3(arc(st, 0.08, 0.02, 0.2, PI/2.0+0.2));\n    color += vec3(arc(st, 0.08, 0.02, 0.2, -PI/2.0+0.2));\n    \n    //rings\n\tcolor += vec3(ring(st, 0.4, 0.025));\n    color += vec3(ring(st, 0.28, 0.025));\n    \n    //center circle\n    color += circle(st, 0.01);\n    \n    //outside circles\n    for(int i = 0; i < 4; i++) {\n    \tcolor += circle(vec2(st.x+0.45*cos(float(i)*PI/2.), st.y + 0.45*sin(float(i)*PI/2.)), 0.010);\n    }\n    \n    //lines within rings\n\tfloat pct = step(0.32, polar.r) * step(polar.r, 0.38);\n    pct *= step(0.02, mod(polar.g, 0.05)) - step(0.03, mod(polar.g, 0.05));\n    color += vec3(pct);\n    \n    gl_FragColor = vec4(color,1.0);\n}\n\n"
    },
    {
        "name": "fbm_orange_moms_edition.frag",
        "data": "// fbm_practice.frag\n// working on some fractal brownian motion\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(1.234,56.789)))*\n        123456.789);\n}\n\nvec2 sin2(in float x, in float y) {\n    return vec2(sin(x), sin(y));\n}\n\n//noise function by interpolating between corners of square\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of square\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define ITERATIONS 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float val = 0.;\n    float amplitude = .5;\n    float frequency = 1.5; \n    float amp_scale = .5; //should be less than 1\n    float freq_scale = 2.; //should be greater than 1\n    \n    //number of \"octaves\" / scaled waves\n    for (int i = 0; i < ITERATIONS; i++) {\n        val += amplitude * noise(st * frequency);\n        frequency *= freq_scale;\n        amplitude *= amp_scale;\n    }\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec2 mouse = u_mouse / u_resolution;\n    mouse.x *= u_resolution.x/u_resolution.y;\n    st.x *= u_resolution.x/u_resolution.y;\n    vec2 rt = st - vec2(0.5);\n\tst *= 4.5;\n    mouse *= 4.5;\n    rt = vec2(length(rt) * 10., atan(rt.y, rt.x));\n    float time = u_time;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    //float fbm0 = fbm(st+vec2(0.490,0.020)+fbm(st+vec2(-0.240,0.090)+fbm(st+10.*vec2(0.680,0.310))));\n    float fbm1 = fbm(st*0.65+time/50.);\n    float fbm2 = fbm(st*fbm1 + time/25. - cos(time/100.)/1.);\n    float fbm3 = fbm(st + fbm2 + vec2(-time/15., time / 15.));\n    float fbm4 = fbm(0.5*sin(st*2.) + fbm3 + time/2.);\n\n\n    //different color variations happening over here!\n    color = vec3(1.);\n    color = mix(vec3(0.4314, 0.0, 0.0), vec3(0.251, 0.1176, 0.502), fbm1);\n    color = mix(color, vec3(1.0, 0.3412, 0.0157), fbm2);\n    color = mix(color, vec3(0.0, 0.0, 0.0), fbm3);\n    // color = mix(color, vec3(0.4941, 0.0, 0.0), .5*fbm4);\n    color *= 1.8;\n\n    //comment out the following line to remove the mouse functionality\n    // if (!(u_mouse.x <= 25. || u_mouse.x >= u_resolution.x -25. || u_mouse.y <= 25. || u_mouse.y >= u_resolution.y - 25.)) {\n    //     // color = mix(color, color / 2., 1.-smoothstep(0.7, 1., 0.8*length(st-mouse)+fbm3));\n    //     color *= mix(vec3(0.0, 0.0, 0.0), vec3(1.) , smoothstep(0.9, 1., 2.*length(st-mouse)+fbm3));\n    // }\n\n    // color = mix(color, vec3(0.0, 0.0, 0.0),1. - step(0.1, (length(st-mouse))));\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "fbm_op.frag",
        "data": "// fbm_practice.frag\n// working on some fractal brownian motion\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(1.234,56.789)))*\n        123456.789);\n}\n\nvec2 sin2(in float x, in float y) {\n    return vec2(sin(x), sin(y));\n}\n\n//noise function by interpolating between corners of square\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of square\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define ITERATIONS 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float val = 0.;\n    float amplitude = .5;\n    float frequency = 1.5; \n    float amp_scale = .5; //should be less than 1\n    float freq_scale = 2.; //should be greater than 1\n    \n    //number of \"octaves\" / scaled waves\n    for (int i = 0; i < ITERATIONS; i++) {\n        val += amplitude * noise(st * frequency);\n        frequency *= freq_scale;\n        amplitude *= amp_scale;\n    }\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec2 mouse = u_mouse / u_resolution;\n    mouse.x *= u_resolution.x/u_resolution.y;\n    st.x *= u_resolution.x/u_resolution.y;\n    vec2 rt = st - vec2(0.5);\n\tst *= 4.5;\n    mouse *= 4.5;\n    rt = vec2(length(rt) * 10., atan(rt.y, rt.x));\n    float time = u_time;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    //float fbm0 = fbm(st+vec2(0.490,0.020)+fbm(st+vec2(-0.240,0.090)+fbm(st+10.*vec2(0.680,0.310))));\n    float fbm1 = fbm(st*0.65+time/50.);\n    float fbm2 = fbm(st*fbm1 + time/25. - cos(time/100.)/1.);\n    float fbm3 = fbm(st + fbm2 + vec2(-time/15., time / 15.));\n    float fbm4 = fbm(0.5*sin(st*2.) + fbm3 + time/2.);\n\n\n    //different color variations happening over here!\n    color = vec3(1.);\n    color = mix(vec3(0.4314, 0.0, 0.0), vec3(0.251, 0.1176, 0.502), fbm1);\n    color = mix(color, vec3(1.0, 0.3412, 0.0157), fbm2);\n    color = mix(color, vec3(0.0, 0.0, 0.0), fbm3);\n    // color = mix(color, vec3(0.4941, 0.0, 0.0), .5*fbm4);\n    color *= 1.8;\n\n    //comment out the following line to remove the mouse functionality\n    // if (!(u_mouse.x <= 25. || u_mouse.x >= u_resolution.x -25. || u_mouse.y <= 25. || u_mouse.y >= u_resolution.y - 25.)) {\n    //     color = mix(color, color / 2., 1.-smoothstep(0.7, 1., 0.8*length(st-mouse)+fbm3));\n    //     //color *= mix(vec3(0.0, 0.0, 0.0), vec3(1.) , smoothstep(0.9, 1., 0.8*length(st-mouse)+fbm3));\n    // }\n\n    // color = mix(color, vec3(0.0, 0.0, 0.0),1. - step(0.1, (length(st-mouse))));\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "fbm_ow.frag",
        "data": "// fbm_practice.frag\n// working on some fractal brownian motion\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(1.234,56.789)))*\n        123456.789);\n}\n\n//noise function by interpolating between corners of square\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of square\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define ITERATIONS 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float val = 0.;\n    float amplitude = .5;\n    float frequency = 1.5; \n    float amp_scale = .5; //should be less than 1\n    float freq_scale = 2.; //should be greater than 1\n    \n    //number of \"octaves\" / scaled waves\n    for (int i = 0; i < ITERATIONS; i++) {\n        val += amplitude * noise(st * frequency);\n        frequency *= freq_scale;\n        amplitude *= amp_scale;\n    }\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec2 mouse = u_mouse / u_resolution;\n    mouse.x *= u_resolution.x/u_resolution.y;\n    st.x *= u_resolution.x/u_resolution.y;\n\tst *= 4.5;\n    mouse *= 4.5;\n\n    float time = u_time;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    //float fbm0 = fbm(st+vec2(0.490,0.020)+fbm(st+vec2(-0.240,0.090)+fbm(st+10.*vec2(0.680,0.310))));\n    float fbm1 = fbm(st+5.*vec2(-0.5,1.5)*.05*cos(0.125*time) - 2.*vec2(0.25, 0.1)*time);\n    float fbm2 = fbm(st+vec2(-0.240,0.090)+0.5*fbm1+ vec2(-0.5 * time, 0.3*sin(st.y+time+noise(st))));\n    float fbm3 = fbm(st+vec2(0.490,0.020)*fbm2 + vec2(0.5, 0.5)*0.1*sin(1.5*time) + 0.1*time + fbm1);\n     \n    //different color variations happening over here!\n    color += mix(vec3(0.8627, 0.502, 0.0863), vec3(0.0706, 0.2784, 0.098), fbm1);\n    color += mix(vec3(0.9176, 0.4431, 0.4431), vec3(0.6039, 0.0471, 0.5294), fbm2);\n    color *= mix(color, vec3(0.0, 0.0, 0.00), clamp(fbm3, 0., 1.));\n    color *= .8;\n    //comment out the following line to remove the mouse functionality\n    if (!(u_mouse.x <= 25. || u_mouse.x >= u_resolution.x -25. || u_mouse.y <= 25. || u_mouse.y >= u_resolution.y - 25.)) {\n        color -= mix(vec3(0.0, 0.0, 0.0), vec3(.9) , 1.-smoothstep(0.7, 1., 0.8*length(st-mouse)+fbm3));\n        //color *= mix(vec3(0.0, 0.0, 0.0), vec3(1.) , smoothstep(0.9, 1., 0.8*length(st-mouse)+fbm3));\n    }\n\n    // color = mix(color, vec3(0.0, 0.0, 0.0),1. - step(0.1, (length(st-mouse))));\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "cellular_noise.frag",
        "data": "//cellular_noise.frag\n//playing with cellular noise and some\n//REALLY annoying \n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define PI 3.141592653589793\n\nvec2 random2( vec2 p) {\n    p.y = mod(p.y, 10.);\n    return fract(sin(\n        vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)))\n                    )*43758.5453);\n}\n\nvec3 hardlines_voronoi(vec2 st) {\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    float mdist = 8.0;\n    vec2 mdiff;\n    \n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 rPoint = random2(n + ipos);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            if(dist < mdist) {\n                mdist = dist;\n                mdiff = diff;\n            } \n\t\t}\n    }\n    \n    mdist = 8.0;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 rPoint = random2(n + ipos);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            \n            if(dot(mdiff-diff, mdiff-diff) > 0.0001) {\n                mdist = min(mdist, abs(dot(0.5*(mdiff+diff), normalize(mdiff-diff))));\n            }\n\t\t}\n    }\n    return vec3(mdist, mdiff);\n}\n\nvec3 hardlines_voronoi_with_point(in vec2 st, in float scale, in vec2 point) {\n    vec2 ipos = floor(st);\n    vec2 fpos = fract(st);\n    \n    float mdist = 8.0;\n    vec2 mdiff;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n        \tvec2 n = vec2(float(i), float(j));\n            vec2 inp = n+ipos;\n            inp.y = mod(inp.y, scale);\n            vec2 rPoint = random2(inp);\n            //rPoint = 0.5+0.5 * sin(u_time+2.*PI*rPoint);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            if(dist < mdist) {\n                mdist = dist;\n                mdiff = diff;\n            } \n\t\t}\n    }\n\n    for(int i = -1; i <= 1; i++) {\n        vec2 pointDiff = point + vec2(0., scale*float(i)) - ipos - fpos;\n        if(dot(pointDiff, pointDiff) < mdist) {\n            mdist = dot(pointDiff, pointDiff);\n            mdiff = pointDiff;\n        }\n    }\n    \n    mdist = 8.0;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 n = vec2(float(i), float(j));\n            vec2 inp = n+ipos;\n            inp.y = mod(inp.y, scale);\n            vec2 rPoint = random2(inp);\n            //rPoint = 0.5+0.5 * sin(u_time+2.*PI*rPoint);\n            vec2 diff = rPoint + n - fpos;\n            float dist = dot(diff, diff);\n            \n            if(dot(mdiff-diff, mdiff-diff) > 0.0001) {\n                mdist = min(mdist, abs(dot(0.5*(mdiff+diff), normalize(mdiff-diff))));\n            }\n\t\t}\n    }\n    return vec3(mdist, mdiff);\n}\n\nvec2 transform(in vec2 st, float scale, vec2 pre_translate, vec2 post_translate) {\n    st -= pre_translate;\n    vec2 uv = vec2(length(st), atan(st.y, st.x));\n    //if(st.x < 0.) uv.y += PI;\n    //uv.y = 0.;\n    uv.y = uv.y/2./PI + 0.5;\n    //uv.y = .5-.5*cos(2.*uv.y*PI);\n    //uv.y = 1.-pow((2.*(uv.y-0.5)),2.);\n    uv *= scale;\n    //uv.y = mod(uv.y, scale);\n    uv.r = 2. * sin(uv.r);\n    uv += post_translate;\n    return uv;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n    const float SCALE = 10.;\n    vec2 mouse = u_mouse / u_resolution;\n    mouse.x *= u_resolution.x / u_resolution.y;\n    vec3 color = vec3(0.349, 0.0353, 0.0);\n    \n//     st -= 0.5;\n    \n//     st = vec2(length(st), atan(st.y, st.x));\n//     st.y = st.y/2./PI + 0.5;\n//     st *= SCALE;\n    st = transform(st, SCALE, vec2(0.5), vec2(u_time, u_time) * vec2(.4, 0.15));\n\tmouse = transform(mouse, SCALE, vec2(0.5), vec2(u_time, u_time) * vec2(0.4, 0.15));\n    \n\tvec3 voronoi = hardlines_voronoi_with_point(st, SCALE, mouse);\n\n    // color += vec3(step(voronoi.x, 0.02));\n    color = mix(vec3(0.4824, 0.0392, 0.0392), vec3(0.7765, 0.2039, 0.0275), voronoi.z);\n    color = mix(vec3(0.6902, 0.4157, 0.5647), vec3(0.1412, 0.2627, 0.5765), voronoi.z);\n    // color = mix(color, vec3(0.3843, 0.0784, 0.0118), voronoi.y);\n\n//     // Show isolines\n    //color -= abs(sin(80.0*m_dist))*0.07;\n\n\t//color += step(length(voronoi.yz), 0.02);\n    \n   //color.r += step(0.98, fract(st.x)) + step(0.98, fract(st.y));// + step(st.y, 4.936);\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "mandelbrot_set.frag",
        "data": "//mandelbrot_set.frag\n//displays the mandelbrot set\n//move mouse across screen to zoom in\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.141592653589793\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\n\nmat2 rotate(float theta) {\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\nvec2 multiply_complex(vec2 z1, vec2 z2) {\n    return vec2(z1.x*z2.x-z1.y*z2.y, z1.y*z2.x+z1.x*z2.y);\n}\n\n#define ITERATIONS 500\nfloat mandelbrot(in vec2 st) {\n    vec2 z = vec2(0.);\n    for(int i = 0; i < ITERATIONS; i++) {\n        if(dot(z,z) > 5.) return float(i);\n        z = multiply_complex(z,z) + st;\n    }\n    return 0.;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy / u_resolution;\n    st.x *= u_resolution.x / u_resolution.y;\n    vec2 mouse = u_mouse / u_resolution;\n    mouse.x *= u_resolution.x / u_resolution.y;\n    mouse.x *= 6.;\n    st -= vec2(.7-.73/3., .5+.23/3.);\n    st *= 3. * exp(-mouse.x);\n    //st *= rotate(u_time * 0.1);\n    float ms = mandelbrot(st+vec2(-.715,0.23));\n\n    vec3 color = vec3(0.);\n    color = vec3(step(0.02, ms));\n    color *= mix(vec3(1.0, 0.4667, .0), vec3(0.2667, 0.0, 1.0), 1.0 - ms / (float(ITERATIONS) / 5.));\n\n    //color += step(-0.002, st.x) * step(st.x, 0.002) + step(-0.002, st.y) * step(st.y, 0.002);\n\n    gl_FragColor = vec4(color, 1.0);\n}"
    },
    {
        "name": "fbm_mosaic.frag",
        "data": "// fbm_practice.frag\n// working on some fractal brownian motion\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(1.234,56.789)))*\n        123456.789);\n}\n\n//noise function by interpolating between corners of square\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of square\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define ITERATIONS 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float val = 0.;\n    float amplitude = .5;\n    float frequency = 1.5; \n    float amp_scale = .5; //should be less than 1\n    float freq_scale = 2.; //should be greater than 1\n    \n    //number of \"octaves\" / scaled waves\n    for (int i = 0; i < ITERATIONS; i++) {\n        val += amplitude * noise(st * frequency);\n        frequency *= freq_scale;\n        amplitude *= amp_scale;\n    }\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec2 mouse = u_mouse.xy / u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n    mouse.x *= u_resolution.x/u_resolution.y;\n    mouse *= 4.5;\n\tst *= 4.5;\n\n    float time = u_time;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    //float fbm0 = fbm(st+vec2(0.490,0.020)+fbm(st+vec2(-0.240,0.090)+fbm(st+10.*vec2(0.680,0.310))));\n    float fbm1 = fbm(st+5.*vec2(-0.5,1.5)*.05*cos(0.125*time) - 2.*vec2(0.25, 0.1)*time);\n    float fbm2 = fbm(st+vec2(-0.240,0.090)+0.5*fbm1+ vec2(-0.5 * time, 0.3*sin(st.y+time+noise(st))));\n    float fbm3 = fbm(st+vec2(0.490,0.020)*fbm2 + vec2(0.5, 0.5)*0.1*sin(1.5*time) + 0.1*time + fbm1);\n     \n    //different color variations happening over here!\n    //color += mix(vec3(0.0863, 0.8627, 0.7451), vec3(0.0706, 0.2784, 0.098), fbm1);\n    //color += mix(vec3(0.0863, 0.8627, 0.7451), vec3(0.6941, 0.4275, 0.0275), fbm1);\n    color += mix(vec3(0.0863, 0.8627, 0.7451), vec3(0.2784, 0.149, 0.0706), fbm1);\n    color += mix(vec3(0.9176, 0.4431, 0.4431), vec3(0.6039, 0.0471, 0.5294), fbm2);\n    color *= mix(color, vec3(0.0392, 0.149, 0.4471), fbm3);\n\n        //comment out the following line to remove the mouse functionality\n    if (!(u_mouse.x <= 25. || u_mouse.x >= u_resolution.x -25. || u_mouse.y <= 25. || u_mouse.y >= u_resolution.y - 25.)) {\n        color += mix(vec3(0.0, 0.0, 0.0), vec3(.3) , 1.-smoothstep(0.7, 1., 0.8*length(st-mouse)+fbm3));\n        //color *= mix(vec3(0.0, 0.0, 0.0), vec3(1.) , smoothstep(0.9, 1., 0.8*length(st-mouse)+fbm3));\n    }\n\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    },
    {
        "name": "circles.frag",
        "data": "//circle.frag\n//circles and distance fields\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nvec3 circle(in vec2 v, vec2 coord, float rad) {\n    vec2 toCenter = coord - v;\n    float pct = length(toCenter);\n    pct = step(rad, pct);\n    return vec3(pct);\n}\n\nvoid main(){\n\tvec2 st = gl_FragCoord.xy/u_resolution;\n    float pct = 0.0;\n\n    // a. The DISTANCE from the pixel to the center\n    //pct = distance(st,vec2(0.5));\n\n    // b. The LENGTH of the vector\n    //    from the pixel to the center\n     //vec2 toCenter = vec2(0.850,0.750)-st;\n     //pct = length(toCenter);\n\n    // c. The SQUARE ROOT of the vector\n    //    from the pixel to the center\n    // vec2 tC = vec2(0.5)-st;\n    // pct = sqrt(tC.x*tC.x+tC.y*tC.y);\n\n    //pct = step(0.3 + (0.1*abs(sin(5.0*u_time))), pct);\n    //pct += sin(u_time);\n    vec3 color; //circle(st, vec2(0.310,0.730), 0.216);\n    //color *= circle(st, vec2(0.740,0.250), 0.2);\n  pct = pow(distance(st,vec2(0.5)), distance(st,vec2(0.5+0.25*sin(2.*u_time),0.5+0.25*cos(2.*u_time))));\n    color = vec3(pct);\n    color += vec3(0.530,0.000,0.010);\n    //color = mix(vec3(0.980,0.154,0.220), color, 1.036);\n    //color = smoothstep(0.296, 0.952, color);\n    //color = step(0.332, color);\n\tgl_FragColor = vec4( color, 1.0 );\n}\n\n"
    },
    {
        "name": "fbm_practice.frag",
        "data": "// fbm_practice.frag\n// working on some fractal brownian motion\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(1.234,56.789)))*\n        123456.789);\n}\n\n//noise function by interpolating between corners of square\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of square\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n#define ITERATIONS 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float val = 0.;\n    float amplitude = .5;\n    float frequency = 1.5; \n    float amp_scale = .5; //should be less than 1\n    float freq_scale = 2.; //should be greater than 1\n    \n    //number of \"octaves\" / scaled waves\n    for (int i = 0; i < ITERATIONS; i++) {\n        val += amplitude * noise(st * frequency);\n        frequency *= freq_scale;\n        amplitude *= amp_scale;\n    }\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n\tst *= 4.5;\n\t\n    vec3 color = vec3(0.0);\n    //float fbm0 = fbm(st+vec2(0.490,0.020)+fbm(st+vec2(-0.240,0.090)+fbm(st+10.*vec2(0.680,0.310))));\n    float fbm1 = fbm(st+10.*vec2(0.680,0.310) - vec2(0.3, 0.1)*u_time);\n    float fbm2 = fbm(st+vec2(-0.240,0.090)+fbm1 + vec2(0.3*sin(st.x+u_time+noise(st)), 0.5 * u_time));\n    float fbm3 = fbm(st+vec2(0.490,0.020) + fbm2+0.3*u_time);\n     \n    //change this value to see different color saturations\n    //right now, 0, 1 or not those :D\n    //I don't *fully* understand these--mostly just playing with values--but I'm getting there\n    int color_choice = 3;\n    if(color_choice == 0) {\n        //color option 1\n        color += mix(vec3(0.), vec3(0.980,0.318,0.004), fbm1);\n        color += mix(vec3(0.), vec3(0.3216, 0.3882, 0.349), fbm2);\n        color += mix(vec3(0.276,0.756,1.000), vec3(0.002,0.000,0.170), fbm3);\n    }\n    else if(color_choice == 1) {\n        //color option 2\n        color = mix(vec3(0.276,0.756,1.000), vec3(0.980,0.318,0.004), fbm1);\n        color += mix(color, vec3(0.3216, 0.3882, 0.349), fbm2);\n        color *= mix(color, vec3(0.002,0.000,0.170), fbm3);\n    }\n    else if(color_choice == 2) {\n        color = mix(vec3(1.0, 0.2902, 0.4667), vec3(0.9804, 0.4745, 0.0039), fbm1);\n        color = mix(color, vec3(0.6157, 0.9765, 0.7412), fbm2);\n        color = mix(color, vec3(0.149, 0.0824, 0.4118), fbm3);\n    }\n    else {\n        color -= mix(vec3(1.0, 0.2902, 0.4667), vec3(0.9804, 0.4745, 0.0039), fbm1);\n        color += mix(color, vec3(1.0, 1.0, 1.0), fbm2);\n        color *= mix(color, vec3(0.2353, 0.0706, 0.4353), fbm3);\n    }\n\n    gl_FragColor = vec4(color,1.0);\n}\n"
    }
]