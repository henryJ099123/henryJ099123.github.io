[
    {
        "urlname": "hello-world",
        "name": "Hello, World",
        "author": "Henry Jochaniewicz",
        "date": "October 21, 2025",
        "id": 0,
        "data": "# Hello, World\n\nHello, world! I won't repeat my bio at length, which you can see on the main page\nof this site, but in case you somehow missed that, my name is Henry Jochaniewicz.\nI'm a current junior at the **University of Notre Dame** studying computer science\nwith minors in mathematics and theology.\n\nDespite how much I enjoy math and CS, I still like to read and write, and think\nit's a necessary skill to keep. I also really, *really* like sharing what I know\nwith other people and teaching the things I know; there's a reason I've been an\nundergraduate teaching assistant for three semesters now. So, I think having\nan outlet and repository for the things I write is a good, useful endeavor.\n\nMost of the notes I write are probably going to be related to computer science,\nprobably as a way to prove to myself I'm actually learning in my classes\nby explaining the concepts I know to the void.\nSome might instead be opinion pieces related to programming, like on valid\nsyntax highlighting or something like that.\nSome of these probably *won't* be CS related; I like video games, books,\nmovies, origami, and lots of other things, so if inspiration strikes, maybe\nI'll write a video game review or something like that and put it here.\n\nRegardless, I hope that these little notes that I write are useful to someone,\nand at least are enjoyable to read.\n\n"
    },
    {
        "urlname": "intro-shaders",
        "name": "Writing Your First Shader",
        "author": "Henry Jochaniewicz",
        "date": "October 24, 2025",
        "id": 1,
        "data": "# Writing Your First Shader\n\nWhile most general programming is procedurally done on the CPU,\nthere's a whole world of programming done on the GPU via shaders.\nShader programming is very different than trying to program anything\non the CPU. It's more challenging, and there are lots of restrictions\n&mdash; but that's what makes it fun!\n\nThis is a short tutorial where we will develop and run a small, simple\nfragment shader. For more information on writing shaders from a different\n(honestly, better) source, see [The Book of Shaders](https://www.thebookofshaders.com),\nwhich is where I initially learned about shaders.\n\n## Shaders and the GPU\n\nShaders are simply programs run on the **graphics processing unit (GPU)** instead\nof the CPU of the computer. They're typically part of the **graphics pipeline**,\nwhich is the process which renders images on a screen, but you can have general\npurpose shaders too (these are known as **compute shaders**).\nYou don't need to fully understand the graphics pipeline to write a small shader,\nbut a bit of context will help understand why there are such restrictions in writing shaders.\n\nShaders are typically used to insert user code to modify aspects of the graphics pipeline.\nThe most common are called **vertex shaders** and **fragment shaders**.\nBroadly, vertex shaders are used to manipulate individual vertices of a **mesh**\n(think a 3D wireframe of a 3D object) near the beginning of the pipeline, \nwhile fragment shaders essentially provide color to the face of an object at the very end.\n\nIn this note, we'll be writing a simple fragment shader to the screen,\ntreating the screen as the face of an object. Before we do that, though,\nIt will be helpful to understand in broad strokes the difference between the GPU\nand the CPU to understand the restrictions of shader programming.\n\nImagine the CPU as a single, smart, capable manager. \nIt can do nearly anything, but it is not good at multitasking. \nWith a single CPU core, it is actually *impossible* for a computer\nto perform two tasks simultaneously without dedicated hardware support.\n\nThe GPU *has* this dedicated hardware support. Imagine the GPU as a bunch (hundreds\nif not thousands) of very stupid workers. They receive instructions from the smart,\ncapable manager, and can *all work simultaneously*.\nHowever, because they're stupid, they can't do nearly the same things the manager can,\nand *they can't communicate between each other*.\n\n> If it wasn't obvious, *workers* is an analogy for *cores*.\n\nGPUs allow extreme parallelism. For example, the code for a fragment shader is run\nfor every pixel on the screen. However, the running shader for a certain pixel (generally)\nis *independent* of that for every other running shader. This means the output\nof a shader can *only be dependent* on specific data (from its nearest vertices).\n\nThat sounds hard, but all it means is we have to be very *functional* in the way\nwe approach shader programming. It will lead to very pretty pictures though!\n\n## GLSL\n\nTo interact with the GPU, there are lots of different **graphics APIs**.\nWhile Vulkan and Metal are more common now, **OpenGL** was by far the most common,\nand is still used today extensively. We're going to be writing shaders\nin the **OpenGL Shader Language (GLSL)**, which is like C in syntax but very much\n*not* like C in many other ways.\n\n> Unfortunately, OpenGL seems to be on its way out now.\n> MacOS has stopped supporting OpenGL after version 4.1 in favor\n> of its own graphics API called **Metal**, which means things\n> like *compute shaders* aren't available to use on Mac machines.\n> This isn't a problem for us today, as every method to run the shader will be\n> operating system agnostic.\n\n## Running a Shader\n\nLet's make sure you have a working environment in which to run shader programs.\nHere are two easy approaches without writing all of the OpenGL graphics pipeline whatnot.\n\n### Processing\n\nI recommend installing [Processing](https://processing.org/download). Processing\nis an awesome programming sketch tool to develop quick graphics. I used Processing\nwhen I was learning how to code, and it can thankfully run shaders agnostic\nof operating system.\n\nYou don't really need to learn Processing or Java at all for this tutorial (though I recommend\nlearning the basics, it's fun!), so below is a small file to run a shader\n(or you can copy it [here](https://github.com/henryJ099123/shader_practice/blob/main/shader_exec.pde)):\n\n```java\nPshader shader;\nString filename = \"my_shader.frag\";\n\nvoid settings() throws IllegalArgumentException {\n    size(640, 640, P2D);\n    if(args != null) {\n        if(args.length > 1)\n            throw new IllegalArgumentException(\"Too many arguments\");\n        else\n            filename = args[0];\n    } \n} \n\nvoid setup() {\n    noStroke();\n    System.out.println(filename);\n    shader = loadShader(filename);\n} \n\nvoid draw() {\n    shader.set(\"u_resolution\", float(width), float(height));\n    shader.set(\"u_mouse\", float(mouseX), float(mouseY));\n    shader.set(\"u_time\", millis() / 1000.0);\n\n    shader(shader);\n    rect(0, 0, width, height);\n} \n```\n\nBasically, this just looks for a file called `my_shader.frag` and outputs it to the screen\non a rectangle. It also sets *uniforms*, which we will get to later.\n\nYou can run this via Processing's IDE (just change `filename` to the path to your shader)\nor via the command line. See below.\n\n```bash\nprocessing-java --sketch=$PWD --run [path_to_your_shader]\n```\n\n### glsl-canvas via VSCode\n\nIf you don't want to install an entirely new IDE, and you use Visual Studio Code,\nyou can use the \n[glsl-canvas](https://marketplace.visualstudio.com/items?itemName=circledev.glsl-canvas)\nextension to have the shaders show up right next to your code\n(this is by far the simplest way to show shaders if you use VS Code).\n\n## Fragment Shaders\n\nNow, time for some actual programming.\nMake a new file called `my_shader.frag` with the following boilerplate:\n\n```glsl\n#version 330\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nout vec4 color;\n\nvoid main() {\n    vec3 temp = vec3(1.0, 0.0, 0.0);\n    color = vec4(temp, 1.0);\n} \n```\n\nThere's already a lot going on here, so let's go line by line.\n\n1. The `#version 330` is simply specifying the version of OpenGL being used\nhere (which is 3.3.0).\n\n2. The next three lines are simply for embedded systems to define how precise floats should be.\nThat can also be ignored. We will come back to `out vec4 color` soon.\n\n3. The actual code is in the `main` function, which is `void` (instead of `int`, as in C).\nHere, we see the types in GLSL. This is not a general purpose language,\nso you won't see strings, characters, or anything like that; you only manipulate numbers\nin GLSL. Therefore, GLSL has the usual types `int`, `uint`, `float`, and `double`, but additionally\nwe see a host of vector types. We can think of these as fixed-size arrays of a specific\ntype. `vec3` is a float vector with three elements, while `vec4` is the same for four elements.\n\n4. We define a local variable `temp` of type `vec3` in the main function. \nIn GLSL, we can construct a `vec3` by manually assigning each of the float elements.\nKeep in mind that GLSL *does not cast for you*. This is to speed things up,\nbut it also means that the following is a compilation error.\n\n```glsl\nvec3 temp = vec3(1, 0, 0);\n```\n\n5. Lastly, we store `temp` in a variable `color`. We defined this outside of `main`,\nand from this line, we see that we can create a `vec4` by placing a `vec3` followed\nby a single component to get all four components. We'll see how powerful\nthis can be soon.\n\n> As a note, you can safely consider these vectors as all passed by *value*.\n> Changing the first coordinate of `color` will not affect `temp` in any way.\n\n6. For a fragment shader, we must define a `vec4` to be \"out\" at the top\nof the file. This indicates that this is the output color for the specified\nfragment to the GPU. This is done instead of *returning* `color`.\n\n> In older versions of GLSL, you may see a hidden global variable\n> `gl_FragColor` being used. This has the same effect as the above.\n\n7. The four coordinates of the `color` variable represent **red**, **green**, \n**blue**, and **alpha** channels. If you're unfamiliar, you can think about\nit as deciding how much of red, blue, or green to mix together.\nAs you can see, these are stored between 0.0 and 1.0, rather\nthan between 0 and 255. This means the values are *normalized*, which makes\ntransformations far, far easier.\n\nThus, this fragment shader has the effect of turning the entire screen red.\nCheck it out below.\n\n![An image of a red screen.](/notes/intro-shaders/intro-shader1-output.png)\n\n## Adding Some Variation\n\nIn the previous example, we simply set every pixel to a flat color.\nLet's try varying the color of a pixel based on its position.\nTo get the actual pixel position and scale it properly, we'll need to do\na bit more work. Time to spice things up.\n\nChange `main` to the following:\n\n```glsl\nuniform vec2 u_resolution;\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy / u_resolution;\n    color = vec4(st.rg, 0.0, 1.0);\n}\n```\n\nWhat did we do here?\n\n1. First, we take a look at `gl_FragCoord`. This is a built-in variable\nin GLSL &mdash; a `vec4` value that stores the screen position of a given pixel. \nWe need to use this to be able to change colors based on pixel position.\n\n    Unfortunately, this is in screen space, and isn't normalized.\n    If our window is 600 pixels wide, that means that a pixel near the middle is\n    has pixel coordinates in the hundreds. That leads us to our next innovation:\n\n2. We declare a `uniform` called `u_resolution`. Uniforms are like global variables.\nThese are values that *every* running instance of the fragment shader can see\nand use, but not set or store. It's common that uniforms change (ironically) between\ndraw calls, but all that's important to know here is that a uniform is a value we set\n**outside** of the shader that *every* running instance of the shader can access.\n\n    > If you are using Processing, you may recall manually setting\n    > `u_resolution` to be the window size.\n\n    Using a uniform lets us *dynamically change* the resolution of our window\n    at runtime and not compromise our fragment shader.\n\n3. We use `u_resolution` to normalize the 2D coordinate of a pixel between 0.0 and 1.0.\nThere's a lot happening in the single line of code here:\n\n    ```glsl\n    vec2 st = gl_FragCoord.xy / u_resolution;\n    ```\n\n    Let's break it down.\n\n    We know we are declaring a local variable called `st` of type `vec2`.\n    The astute reader may ask, isn't `gl_FragCoord` a `vec4`? \n    Is this not a *type mismatch*? Well, reader, you are correct, but also wrong!\n\n    We can access specific coordinates of a vector by using the **dot notation** above.\n    By typing `gl_FragCoord.xy`, we are getting a `vec2` containing the first two\n    components of `gl_FragCoord`, its `x` and `y`.\n    This is known as **swizzling**, and is an incredibly expressive tool in GLSL.\n\n    There is a *lot* of freedom with swizzling here.\n    We can access the components of a vector via `.x`, `.y`, `.z`, and `.w`.\n    Suppose that \n\n    ```glsl\n    gl_FragCoord = vec4(1.0, 2.0, 3.0, 4.0);\n    ```\n\n    Then here are some examples of vector swizzling:\n\n    ```glsl\n    gl_FragCoord.yx == vec2(2.0, 1.0);\n    gl_FragCoord.zyxw == vec2(3.0, 2.0, 1.0, 4.0);\n    gl_FragCoord.xxy == vec3(1.0, 1.0, 2.0);\n    ```\n\n    > We can also use `.rgba` in place of `.xyzw`. Useful for colors!\n\n    You will find vector swizzling an invaluable tool for writing fragment shaders.\n\n    Returning to our line of code,\n    we perform component-wise division with the resolution. This has the effect\n    of scaling the horizontal coordinate and vertical coordinate between 0.0 and 1.0,\n    as `u_resolution` has the maximum sizes of each component.\n\n    Thus, `st` stores the *normalized position* of a given pixel on the screen.\n\n5. Lastly, we set the *red* and *green* color channels to the first two components\nof `st`, respectively (we could have just written `st` or `st.xy` instead of `st.rg`).\n\nYou should observe the following effect.\n\n![An image of a varying green and blue.](/notes/intro-shaders/intro-shader2-output.png)\n\nTake some time to understand this image. In GLSL, we don't have the luxury\nof a print function to debug or understand our code. Instead,\nwe have to observe the effects via the fragment shader. Therefore, it is imperative\nto understand how a given image is produced.\n\nThe red color channel is set to the x-coordinate of a pixel, and the green channel\nis set to the y-coordinate. So, we can deduce the bottom-left corner of our space\nis the origin.\n\nTake the time to appreciate how we produced this output. We produced our output\nas a simple function of the position of our pixel. This will be a running theme\nin fragment programming: you will have to produce the desired output simply\nbased on the position of the pixel (or based on another texture or image).\n\nCongratulations! You've written your first fragment shader.\nThough, it's kind of trivial. Let's spice it up with the introduction of one more thing:\nfunctions.\n\n"
    }
]